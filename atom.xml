<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[taninnosorani blog]]></title>
  <link href="http://taninno.github.io/atom.xml" rel="self"/>
  <link href="http://taninno.github.io/"/>
  <updated>2015-12-23T19:15:39+09:00</updated>
  <id>http://taninno.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[freeeでのSketch運用の実態]]></title>
    <link href="http://taninno.github.io/blog/2015/12/23/sketch-tips/"/>
    <updated>2015-12-23T15:19:24+09:00</updated>
    <id>http://taninno.github.io/blog/2015/12/23/sketch-tips</id>
    <content type="html"><![CDATA[<p>10月頃にfreeeの社内でSketchの勉強会を開催しました。その勉強会の感想で「社内事例を聞いてみたい」「外部サービスとの連携した際のモックアップ検証方法」「山田さんのSketch芸を見てみたい」という声を頂いため、ブログという形でfreeeで実際に使用しているtipsを添えた社内事例をご紹介したいと思います。</p>

<p>この記事は<a href="http://qiita.com/advent-calendar/2015/sketch3">Sketch 3 Advent Calendar 2015</a> の 23日目のエントリーになります。ちなみにfreeeでは企業カテゴリで<a href="http://qiita.com/advent-calendar/2015/freee">freee Engineers Advent Calendar 2015</a>に参加しています。エンジニア向けの記事が多いですが、とても面白いので宜しければこちらもご一読下さい。</p>

<!-- more -->


<p><em>Sketchの基本的な操作方法はここでは省略させていただきます。Sketchに興味がある方は上記のSketchのAdventCalendarがとても参考になります。</em></p>

<h3>デザインの前に</h3>

<p><img src="http://taninno.github.io/images/sketch/01.png" title="auto auto" ><br/>
早速、画面デザインを実際の流れに沿って紹介をしていきたいと思います。ちなみにfreeeでは画面設計に入る前にDesignDocという課題の整理を行います。これはデザイナーに限らずfreeeのプロダクト開発をする全員が必ず行います。そもそもこの課題は何が問題なのか、その課題に取り組む背景とはなにか、その課題がクリアされたとする状態とはなにかなど、これから取り組む施策を明確にし、1ヶ月後の振り返りの際にどの程度達成されているか検証します。</p>

<p>課題が整理されたとして、それではSketchを起動させましょう。</p>

<h3>ファイルの管理方法</h3>

<p>まず最初は地味ですがファイルの管理方法に関してです。Photoshopでは基本的には1ファイルに1画面だったため、ファイル名に施策や画面名を名付けていましたが、SketchにはPages機能があるためこれを利用します。Fireworksのページに似た機能なので、これを使ってプロジェクト毎の管理もSketchで行います。<br/>
<img src="http://taninno.github.io/images/sketch/02.png" title="auto auto" ><br/>
1つのページのキャンバス内には複数のArtboardを配置できるので、例えば複数の画面に跨ぐチュートリアル画面やモバイルアプリのCRUD系の画面も1つのページとして管理します。</p>

<p>Pagesの説明が長くなってしまいましたが、これによって基本的には1個のSketchファイルを管理するだけで済みます。ただ、あるSketchファイルは30ページ以上もあるのですが、ページ数が増えるとそれだけファイルサイズが増えるので、freeeのプロダクト別にSketchファイルを分けています。<br/>
<img src="http://taninno.github.io/images/sketch/03.png" title="auto auto" ></p>

<h3>Artboardの配置ルール</h3>

<p>ファイルとページが用意できたので、次にArtboardを使って画面を作成していきます。Artboardはキャンバス内のどこにでも配置できますが、以下の簡単な配置ルールを設けています。ルールと言っても気にしているレベルですが…</p>

<ul>
<li><strong>複数画面になる場合は下に遷移先の画面を配置する</strong>。つまり下側に遷移先の画面が連なっていくことになります。モバイルの時もだいたい同じです。</li>
<li><strong>当該画面の右際には別ステートのAartboardを配置する</strong>。hover状態やバルーン系の別レイヤーを表示させた状態の専用Artboardになります。</li>
<li><strong>参考画面をステートArtboardのさらに右側に配置する</strong>。例えば既存画面や参考にしたいデザインなどをArtboardは用いずキャンバス上に配置します。多い時には20画面ぐらい横に並びます。</li>
<li><strong>古いバージョンの画面を左側に配置する</strong>。個人的によく前に作ったものを参照したくなることが多いので、捨てずに隣に置いておくようにしています。</li>
</ul>


<p><img src="http://taninno.github.io/images/sketch/04.png" title="auto auto" ></p>

<p>参考画面や前versionは比較やすいように左右に配置することが多いことから自然とこのような配置になっています。</p>

<h3>UI Component</h3>

<p>Component系はSketchResourcesから公開されているSketchファイルを利用します。<br/>
<img src="http://taninno.github.io/images/sketch/05.png" title="auto auto" ></p>

<p>Yosemite UI 特有のComponentもありますのでセレクトボックスやラジオボタンなどの外観のUIも簡単に用意することができます。<br/>
<img src="http://taninno.github.io/images/sketch/06.png" title="auto auto" ></p>

<h3>zeplin</h3>

<p>以前の<a href="http://localhost:4000/blog/2015/07/20/how-about-zeplin/">記事</a>でもご紹介しましたが、freeeでは去年から<a href="https://zeplin.io/">zeplin</a>を使用しています。zeplin自体の詳細はそちらを参照していただくとして、Sketchでの運用方法に関してご紹介します。</p>

<h4>slackとの連携</h4>

<p>freeeではチャットツールのslackを使用しており、zeplinとslackを連携することができます。<br/>
<img src="http://taninno.github.io/images/sketch/07.png" title="auto auto" ></p>

<h4>外部との連携</h4>

<p>プロダクト以外のLPなどの制作は外部のパートナーさんに実装をお願いする場合もあります。その際に社内で作成したデザインを共有する際にzeplinを利用しています。zeplinはコメント機能があるので「ここのパーツが足りないですよ」「すみません！すぐに用意します」といったパートナーさんへの謝罪のやりとりもzeplinで行っています。ちなみにコメントはslackにも通知されるので返信し忘れも防ぎやすくなります。
<img src="http://taninno.github.io/images/sketch/08.png" title="auto auto" ></p>

<h3>モックアップ連携</h3>

<p><a href="http://www.invisionapp.com/">inVsion</a>, <a href="https://marvelapp.com/">marvel</a>などのモックアップサービスと連携しています。</p>

<h3>最後に</h3>

<p>以上、細かな話になりましたがSketchの運用Tipsになります。ちなみにSketchは便利なツールですが、いつもSketchを使っているわけではなく、画面の一部分のレイアウトをちょっと変えるくらいなら紙とペンで終わらせ、画面遷移が連続して20回くらい以上あるなら<a href="http://taninno.github.io/blog/2013/09/12/justinmind-prototyper/">justinmindでモックアップ検証</a>を先に着手するようにプロジェクトの規模ごとにツールを選定しています。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[freeeではZeplinを使っています]]></title>
    <link href="http://taninno.github.io/blog/2015/07/20/how-about-zeplin/"/>
    <updated>2015-07-20T02:56:34+09:00</updated>
    <id>http://taninno.github.io/blog/2015/07/20/how-about-zeplin</id>
    <content type="html"><![CDATA[<p><a href="https://zeplin.io/">Zeplin</a>はドローイングツールの<a href="http://bohemiancoding.com/sketch/">Sketch</a>で作ったデザインをWebブラウザ上から簡単に確認できるツールです。今年の7月7日に<a href="https://twitter.com/zeplin_io/status/618224626238291970">1.0がリリース</a>され、<a href="https://www.youtube.com/watch?v=o9kOpAaDpQU">画像出力機能</a>が（やっと）追加されました。これで今まで手間であったデザイナーとエンジニアのデザインの受け渡しが自動で出来るようになりました。ちなみにfreeeでは$25/月のGrowingBusinessプランを買っています。</p>

<p><img src="http://taninno.github.io/images/zeplin/01.png" title="auto auto" ></p>

<!-- more -->


<h2>Zeplinの機能</h2>

<p>Zeplinは去年ローンチしてからまだ1年ほどしか経っていないため、なんでも揃っている多機能なツールではありません。ですが、だからなのか割と軽量ですし必要な機能は揃っていると思います。</p>

<h3>サイズ</h3>

<p>余白の距離やパーツの縦横、カラーコードを取得できるのがZeplinのメイン機能です。</p>

<p><img src="http://taninno.github.io/images/zeplin/07.png" title="auto auto" ><br/>
<span style="color:#ccc">Androidのdp単位にも対応している</span></p>

<h3>画像出力</h3>

<p>1.0になって新しく追加されたのがPNGファイルを出力してくれる機能です。SVG形式やモバイル向けに解像度別にも対応しています。ただ画像ファイルの最適化はしてくれないのでダウンロード後は自分で軽量化しないといけません（ここもやってほしいですね）。</p>

<p><img src="http://taninno.github.io/images/zeplin/08.png" title="auto auto" ><br/>
<span style="color:#ccc">Androidのdp単位にも対応している</span></p>

<h3>Webブラウザにも対応</h3>

<p>最初のZeplinはクライアントアプリケーションとして始まりましたが、今ではWebブラウザ上で確認することができます。以前はエンジニアの方にお願いしてMacアプリをインストールしてもらっていましたが、デザインを更新したらアプリをわざわざ立ち上げないといけないのでとても申し訳なくて。それがブラウザベースで表示できるようになるとURLを社内チャットで送るだけでいいのでとても簡単になりました。</p>

<p><img src="http://taninno.github.io/images/zeplin/06.png" title="auto auto" ><br/>
<span style="color:#ccc">freeeのAndroid版の請求書画面もZeplinを使用した</span></p>

<h3>テキストのコピー</h3>

<p>地味なんですが嬉しい機能が文章をコピーできることです。Photoshopとかでもそうですが、デザインツール上のテキストはコピーが面倒だったりします。一部のモックアップツールで作ればテキスト選択も可能ですが、Zeplinならデザイン段階後でもコピーが可能になります。</p>

<p><img src="http://taninno.github.io/images/zeplin/09.png" title="auto auto" ><br/>
<span style="color:#ccc">&ldquo;freeeでは請求書と一緒に取引データが作成されます。取引は会計や請求書の入金などを管理するための情報です。&rdquo;</span></p>

<h3>カラーガイドライン</h3>

<p>正直、あまり使いませんが、Sketchで使用した配色を各形式ごとにカラースキームとして出力することができます。以下の画面はLESS形式のCSSを選択しています。変数名もZeplinで変更できます。</p>

<p><img src="http://taninno.github.io/images/zeplin/10.png" title="auto auto" ><br/>
<span style="color:#ccc">iOS,Androidの形式にも対応しています。</span></p>

<pre><code>@freee_green: #00ac9c
@freee_yellow: #f9ed00
@freee_border_color: #e3e3e3
</code></pre>

<p><span style="color:#ccc">例）LESS</span></p>

<h2>コラボレーションツールの歴史</h2>

<p>デザイナーとエンジニアの協業のためのコラボレーションツールは以前から作られてきましたが普及するまでには至りませんでした。</p>

<h3>昔のデザインの受け渡し</h3>

<p>デザインとコードの担当を分業しているところでは、Photoshopのスライスツールで画像を書き出してExcelにassets一覧シートを作っていたと思います。場合によってはエンジニアがシートに記載してある画像ファイルのフォルダを開いてプロジェクトファイルに移動させたり…とても面倒でした。</p>

<p><img src="http://taninno.github.io/images/zeplin/03.png" title="auto auto" ></p>

<h3>コラボレーションツールの登場</h3>

<p>2004年にAdobeからFlex Builder、2007年にMicrosoftからExpression Blendがリリースされました。</p>

<h4>Flex Builder</h4>

<p><img src="http://taninno.github.io/images/zeplin/04.png" title="auto auto" ><br/>
<span style="color:#ccc">Flex Builder</span></p>

<p>Flex Builderはエンジニアが画面を作りやすいようにFlashのUIComponentをペタペタ貼っていくだけで作れるようになったことが便利でした。ただ、コラボレーションツールというよりもこれまでFlashで作っていて大変だったエンジニア向けのエディタという位置づけでした。</p>

<h4>Flash Catalyst</h4>

<p><img src="http://taninno.github.io/images/zeplin/05.png" title="auto auto" ><br/>
<span style="color:#ccc">Flash Catalyst</span></p>

<p>その後、Flexのデザイナー向けにFlash Catalystが2008年に公開されました。当時は初めての本格的なコラボレーションツールとして注目されましたが、結果的にデザイナーには普及しませんでした。動作がとても重かったのを覚えています。ちなみに2012年に開発が終了しました。</p>

<h4>Expression Blend</h4>

<p><img src="http://taninno.github.io/images/zeplin/02.png" title="auto auto" ><br/>
<span style="color:#ccc">Expression Blend</span></p>

<p>Expression BlendはMicrosoft Platform向けのUI設計ツールです。Flexよりもデザイナーとエンジニアの協業をより意識されていました。BlendでUIを作成するとXAMLと呼ばれるXMLが自動で生成されます。XAMLはコードエディアのMicrosoft Visual Studioから編集することができるので、XAMLを介してデザイナーとエンジニアが共通のソースコードを扱うことができます。</p>

<p>ただ、Blendが公開されたときにデザイナーとエンジニアが同じソースで作業できると期待していましたが、実際にはエンジニア側はXAMLがまるでHTMLのようで慣れず、デザイナー側はWPFなどのレイアウトコンポーネントの仕様を意識してデザインする必要があるため負担が増えてしまいました。結果、デザイナーとエンジニアの間にBlendでUIを作成するインタラクションデザイナー（今で言うフロントエンドエンジニア）というロールが生まれました。同じPlatformで作業すればもちろん効率的ですが、そのための学習コストが高くなります。</p>

<h3>サイズを共有するために</h3>

<p>inkやAssistor PS</p>

<h2>freeeでのデザイナーの役割</h2>

<p>実はZeplinを使うのは稀で、作業の殆どは課題の整理とモックアップの作成をおこなっています。ただ、ビジュアルが重要な場合にはデザインをおこすので、細かなサイズ感などを開発側に伝えるのにZeplinを使っています。</p>

<p>そんなfreeeでは一緒に働いてくれるUIデザイナーを募集しています。</p>

<iframe frameborder='0' height='305px' name='wantedly_project_widget_24981' scrolling='no' src='https://www.wantedly.com/projects/24981/widget' style='border: none; max-width: 100%; min-width: 240px; width: 540px;'></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[スタートアップでの意思決定を含めたUI設計プロセス]]></title>
    <link href="http://taninno.github.io/blog/2015/05/04/start-up-ui-process/"/>
    <updated>2015-05-04T01:40:58+09:00</updated>
    <id>http://taninno.github.io/blog/2015/05/04/start-up-ui-process</id>
    <content type="html"><![CDATA[<p>以前に書いた「<a href="http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/">問題解決型UXデザインアプローチ</a>」はクライアントワークなどの受諾を想定したプロセスでした。それとは違い<a href="http://freee.co.jp">freee</a>のようなエンジニアが爆速で実装をしている中でのUI設計のプロセスをまとめたいと思います。</p>

<!-- more -->


<h2>昔のプロセス</h2>

<p><img src="http://taninno.github.io/images/post/ux.png" title="auto auto" >　</p>

<ol>
<li>理解</li>
<li>アイディア</li>
<li>ストーリー</li>
<li>UI</li>
<li>ビジュアルデザイン</li>
<li>開発</li>
<li>フィードバック</li>
</ol>


<h2>現在</h2>

<p><img src="http://taninno.github.io/images/process/01.png" width="720" title="auto" >　</p>

<h3>コミュニケーション用資料の削減</h3>

<p>昔と大きく変わったのは3.ストーリーと4.UIのプロセスをほとんど簡略したことです。3.はアイディアの共有が目的で、4.は画面の共有が目的でした。どちらも関係者とのコミュニケーションのためのプロセスですが、<strong>今は関係者が自分を含めて2人だけの少数の場合が多く、以前のような会ったことのない別会社の関係者への意思疎通の為の作業は必要無くなりました。</strong>ただ、もちろんスタートアップはスケールアップするため、この方法がいつまで出来るかわかりません。100人規模では成立していますが、どこかで「思いがそれぞれ違う人の方向性を合わせるコンセプト資料」と「自分が直接説明できない伝言ゲーム用の詳細画面設計書」が必要になるかもしれません。今は考えが似ていて直接説明できるチーム規模だからこそ、先の3.と4.のプロセスを減らすことができました。</p>

<h2>新しいプロセス</h2>

<p>コミュニケーション資料が減ったからといっても、１つ１つのTaskのゴールがなにで、どこまでやるのか、といった共通認識は重要です。むしろ気付いたら実装が終わっているほど実装サイクルが早いスタートアップでは、むしろ最初のkickoffでの舵取りがプロジェクトを左右します。</p>

<h3>プラン</h3>

<p>最初に課題を見つけたり、もっと改善できそうなところがあるとまずはプラン（提案書）を作ります。提案書と言ってもWord１ページ分の簡単な文章です。口頭で言うと<strong>「こんな課題があり、原因はこれで、策としてXXXを考えていて、効果としては◯◯◯を見込んでいる」</strong>といった簡単なものです。ただ課題として挙げられた箇所は本当にそうなのかという裏付けは必要です。それらは事前に定量的な仮設を集めます（時には数字を出さなくても明確に改善が必要だと判断することもありますが）。</p>

<h3>プラニング</h3>

<p>上記のプランをチームに披露します。プロジェクト規模が大きればリードレベルやデータアナリストの人達にも声を掛けます。<strong>この場では方向性は合っているか、スコープは広げすぎてないか、逆に漏れはないか、効果はありそうかなど意見をもらいます。</strong>そして懸念事項が上がり、大きくは問題が無いとなったならば振り返り日を決めて、その日にKPIなどの指標の達成度合いを確認します。このような場をプラニングと言っていますが、プロジェクトがスタートするので一般的にはキックオフに近いかもしれません（ちなみにそれほど用語には意味は無く、プラニングが最初のMTG,キックオフが２回目のMTGという程度に考えています）。ただ、UIチームは披露するアウトプットが異なります。プラニングではコンセプトの共有、キックオフではモックアップの共有にフォーカスします。</p>

<h3>ラフスケッチとモックアップ</h3>

<p>プラニングで方向性が定まったらUIらしい作業に入ります。ここではワイヤフレームは作らずラフスケッチとモックアップを作成します。なぜワイヤフレームを作らないかは<a href="http://taninno.github.io/blog/2013/09/12/justinmind-prototyper/">Prototyperを使ったモックアップ主導のUI設計プロセス</a>を参照ください。スケッチからモックアップへの流れは変わっていません。</p>

<h3>キックオフ</h3>

<p>プラニングが終わったら、次回のMTGでは初めて関係者全員（といっても数人程度）が集まります。<strong>この段階では最初のモックアップが荒くても出来上がってるようにします。</strong>議論のたたき台としてある程度が形になっていたほうが議論もしやすく、関係ない話に発展することも無くなります。もちろん全く別物になることも有りますが、触れる画面が何も無いと頭で想像して議論することになり、そうなると大抵結論がでませんし、この段階ではどうでもいい細かい所の話（イレギュラーケースなど）になりがちです。それを防ぐためにたたき台が必要です。さらに複数案あると尚いいです。</p>

<h3>振り返り</h3>

<p>ここではプラニングの時に決めていた指標が達成されているかどうかを振り返ります。その他にも気付いたことを話し合い、次のイテレーションのためのヒアリングを行います。</p>

<h2>推測よりも測定</h2>

<p>以前の受諾向けのUXプロセスでは調査フェイズだけで長いもので数ヶ月の時間がありました。プロジェクトも組織の規模も大きからこそ初期検討が重要でした。それがスタートアップのような環境では仮説検証にそれほど時間は掛けず、<strong>実際にリリースして結果を測定することを大切にしています。</strong>必要なのか悩んだらとりあえずやってみて改善したら良し、ダメだったら次の施策に活かせば良い。コストを掛けずにABテストが短いイテレーションで実施できる社内事業だからこそで、UI設計に外部の受諾コンサルがいると気軽に試してみるというのがやや難しくなります。ただ、これは規模が大きかった受諾の場合とどっちが良いかという話ではなく、時間も人も足りないが、失敗は比較的許されるスタートアップの事情もあります。</p>

<h2>参考:デザインツール</h2>

<p>少ない時間と詳細な画面設計書を作らない代わりに画面の共有を常に行っています。そのために以下のようなモックアップ・プロトタイピングツールを使っています。</p>

<h3>Justinmind (<a href="http://www.justinmind.com">www.justinmind.com</a>)</h3>

<p><img src="http://taninno.github.io/images/process/justinmind.png" title="auto auto" ><br/>
以前に<a href="http://taninno.github.io/blog/2013/09/12/justinmind-prototyper/">Prototyperを使ったモックアップ主導のUI設計プロセス</a>で書いたPrototyperが名前を変えて社名でもあるJustinmindになりました。Justinmindは多機能系のモックアップ（プロトタイピング）ツールです。主にモックアップ作成に用いています。最近ちょっと挙動が重いので、<a href="http://www.weld.io">weld.</a>に移行しようかと思っています。</p>

<h3>Sketch3 (<a href="http://bohemiancoding.com/">bohemiancoding.com</a>)</h3>

<p><img src="http://taninno.github.io/images/process/sketch.png" title="auto auto" ><br/>
UIパーツのほとんど共通のものを使うのでモックアップが終わると実装に入ることもありますが、時には新しいレイアウト・パーツが必要となることがあるので、ドローイングツールのSketchを使ってデザイン画をおこします。Photoshopより便利ですし、後述するzeplinとの連携のためにもsketchを使っています。</p>

<h3>inVision (<a href="http://www.invisionapp.com">www.invisionapp.com</a>)</h3>

<p><img src="http://taninno.github.io/images/process/inVision.png" title="auto auto" ><br/>
Justinmindでモックアップは作っていましたが、その後Sketchでデザインを描いているとモックアップが古くなってしまうので、画像ファイルからモックアップを作れるinVisionを使います。最近ではProttなどのツールも検討しています。</p>

<h3>zeplin (<a href="http://zeplin.io">zeplin.io</a>)</h3>

<p><img src="http://taninno.github.io/images/process/zeplin.png" title="auto auto" ><br/>
エンジニアにデザインを渡すときにSketch上でサイズやカラーコードを生成できる<a href="https://medium.com/sketch-tricks/sketch-measure-master-a-thorough-walkthrough-57d3df25a1cf">Sketch Measure</a>を使ったりしますが、画面の量が多いといくら自動とはいえ、パーツを指定するのは手作業なので少し大変です。そこでsketchのレイアウト情報をWeb上に表示できるzeplinを使用します。これでエンジニアにはURLだけ渡しとけば、後はブラウザ上からmargin値やfont-size、文章もコピペできるようになります。出来れば画像ファイルもzeplinから出力できればいいのですが、次のメジャーアップデートで対応してくれるそうです。</p>

<h3>weld (<a href="http://www.weld.io">weld.io</a>)</h3>

<p><img src="http://taninno.github.io/images/process/weld.png" title="auto auto" ><br/>
モックアップにはjustinmindを使っていますが、weldがシンプルで使いやすそうなので検討しています。justinmindは多機能なのは良いのですが、その分使い勝手や動作が犠牲になっているので、気軽に使えるモックアップツールとしてweldに期待しています。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[シナリオに対するエンジニアとの共通理解]]></title>
    <link href="http://taninno.github.io/blog/2014/08/31/plot-based-on-sequence-diagram/"/>
    <updated>2014-08-31T16:44:53+09:00</updated>
    <id>http://taninno.github.io/blog/2014/08/31/plot-based-on-sequence-diagram</id>
    <content type="html"><![CDATA[<p>スタートアップに適したUI設計を試している中で、ペルソナ・シナリオ法を参考にエンジニアと協業しやすいシナリオ設計を記載しています。また内容は随時更新しています。</p>

<!-- more -->


<h2>シナリオを使ったサービスの設計</h2>

<p>UIを作る時に最初にPhotoshopで作り始めると手戻りが大変なので、その前にワイヤーフレーム（下書き）を描きますが、それでもワイヤーフレームを何枚も描くのは大変ので、精度を上げるためにユーザーの行動を文章で定義します。文章なら書き直しがあってもワイヤーフレームより楽です。<strong>さらにシナリオは具体的な画面要素には触れないので、ユーザビリティテストの手順書としても最適です</strong>。なのでシナリオを作っとくと後々楽になります。逆にシナリオを作らないとUIデザインの時に具体的な利用シーンが想像できず、誰が何のために操作するサービスなのかブレてしまう可能性があります。</p>

<h2>シナリオの下書きとしてのプロット</h2>

<p>ここでのシナリオは小説や台本のようなものを指します。そして、その小説には構想を練るための下書きとなるプロットが必要です。UIデザインをする上でこのプロットが重要だと思います。<strong>プロットはサービスに対するユーザーの時間軸上の行動や推測される発言内容を考えていき、そのために必要な機能や予想される不具合をまとめたものです</strong>。UIデザインの際にこの表があると、UIのバランスがブレないくなります。特に複数の画面に跨る場合は画面間の文脈が重要となるためにこの資料は必須です。時間が無い時はプロットだけを作成してシナリオを作らないこともありますが、プロットだけは必ず作るようにしています。</p>

<p><img src="http://taninno.github.io/images/post/plot.png" width="720" title="auto" ></p>

<p>左から「タスクNo.」「タスク名」「ユーザーの行動」「ユーザーが思ったこと」「タスクを完了するのに必要な機能」「備考（予想される不具合）」を記載します。</p>

<p>上記の表は「ブループリント」や狭義の「カスタマージャーニーマップ（UXマップ）」と同じ役割かもしれませんが、ブループリントよりもサービス全体を網羅せず簡略化させ、ジャーニーマップと比較すると感情曲線は無くし、メインシナリオ+イレギュラーシナリオを含むイメージです。あくまでイメージですが、自分なりに必要最小限に絞ったものをプロットとしています。</p>

<h2>問題はプロット作りには時間が掛かること</h2>

<p>プロットがあることでユースケースが整理されUIが考えやすくなりますが、プロットを作るだけでもそれなりに時間がかかります。多くのUXデザイナーがいればいいですが、スタートアップなど人手が足りない時にはプロットの作成が怠りがちになります。私も忙しいときには楽をしていきなりPhotoshopでデザイン画を起こそうとしてしまいますが、大抵その後ユーザーがどういう気持でこの画面に訪れてきているのか分からなくなります。</p>

<h2>エンジニア自身がプロットを作成する</h2>

<p>そこで、プロットの作成をエンジニアの方にお願いするようにします（忙しいエンジニアの方にとっては面倒かもしれませんが）。ただいきなりプロットを依頼しても手間となってしまうため、<strong>エンジニアが慣れ親しんでいるユースケース図のオブジェクトをユーザーに置き換えて考えてもらいます</strong>。</p>

<p><img src="http://taninno.github.io/images/post/sequence.png" width="640" title="auto" ></p>

<p>縦のオブジェクトにはユーザー（ペルソナ）を当てます。ユーザーが複数ならオブジェクトを追加してもらいます。又、オブジェクトにはPCやモバイルなどのプラットフォームも用意します。それらのオブジェクトに対する操作やプッシュなどはシーケンス図のメッセージとして記載します。これによってプロットに記載する「タスクNo.」「タスク名」「ユーザーの行動」「タスクを完了するのに必要な機能」がユースケース図で置き換えられます。残りの「ユーザーが思ったこと」「備考（予想される不具合）」は考えなければなりませんが、既に時間軸上でユーザーの行動が記載されていれば作業時間を短くできます。</p>

<h2>最初は一緒に書きましょう</h2>

<p>シーケンス図によってプロットの作成が置き換えられたといっても「タスクを完了するのに必要な機能」自体が最適どうかはわかりません。ここはプロットの中でも特に何度も想像を繰り返す大変な項目欄ですが、ここをエンジニアの方と一緒に考えることで同じゴールを向いて作業できるようになり、エンジニアとの協業が後々楽になります。エンジニアとUIを誤認したまま進むよりは「タスクを完了するのに必要な機能」を具体的でなくても、どうなったらユーザーが喜ぶかを話し合っておくことが大切だと思います。何より炎上するような案件は大体ここが疎かになっていることが多いと思います。</p>

<h2>いずれはUXデザイナーがいなくても</h2>

<p>ユースケース図をエンジニアとUXデザイナーの共通言語にすることでゴールへの認識齟齬を防ぎ、エンジニアのUXセンスも高まっていきます。最初は共同で作成することが必要かと思いますが、エンジニアが慣れてきたらUXデザイナーが参加せずともシナリオが作成できるようになり、あとはUIデザイナーへ機能項目を伝えるだけで開発フローが完結します。これにより個々のプロットの作成が負担となっていたUXデザイナーがよりリサーチやアイディア、コンセプトに方にも注力できるようになります。エンジニアにとってはUX→UI→開発を一貫して行えるようになるようになります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[家計簿アプリCart]]></title>
    <link href="http://taninno.github.io/blog/2014/06/14/cart/"/>
    <updated>2014-06-14T22:27:00+09:00</updated>
    <id>http://taninno.github.io/blog/2014/06/14/cart</id>
    <content type="html"><![CDATA[<h2>Cartは写真で記録する新しい家計簿です</h2>

<p><img src="http://taninno.github.io/images/cart/list.png" width="240" title="auto" >　
<img src="http://taninno.github.io/images/cart/cart.png" width="240" title="auto" ></p>

<h3>そもそも家計簿とは？</h3>

<p>家計簿をつける目的は、どれだけの支出があって、それが収入に収まっているのかを管理して把握するためにあると思います。<strong>ですが管理することが目的になってしまい、帳簿のたくさんの数字を見ても実感がわかなかったりすることもあるかと思います</strong>。結局、支出を把握するのに「日用品」「交通費」「娯楽」などに分けても数字上の「娯楽」は先月と増えた減ったの参考になるだけで、どれだけの支出だったのかを把握するのには向いていないと考えました。</p>

<h3>Cartの特徴</h3>

<p>家計簿に本当に必要なのは細かな分類や金額ではなく、何を買ったのかを思い出すことです。そういう意味ではCartは<strong>大雑把な家計簿です</strong>。Cartの家計簿はどんな買い物をして、どれくらいのお金を使っているのかを思い出すためにあります。そのために写真と位置情報と時刻を記録しています。例えばスーパーのレジを読み取って細かな商品名と金額を記録するよりも、レジ袋を撮影して合計金額を入力するほうが後で見返したときに写真と場所から当時の買い物をしていた時の記憶が蘇りやすくなります。</p>

<h3>オススメの使い方</h3>

<ol>
<li><strong>買い物をしているときに商品を撮影して、おおよその金額を入力します</strong>。</li>
</ol>


<p>これだけです。<br/>
細かな金額や分類は必要ありません。Cartにとって大切なのは何にどれだけ使ったのかを管理することではないので、金額も大雑把に気楽に使います。バスに乗ったら「交通費」なんて入力しなくても、例えばバスから見える景色を撮影してもいいと思います。そして、<strong>1日使ってみたら以外なほどに買い物の回数が多いことに驚かれるかもしれません。これは帳簿で管理する家計簿では体験できません</strong>。もし細かな金額や分類で管理されたい方は別の家計簿アプリが良いかと思います。特に<a href="https://moneyforward.com/">マネーフォワード</a>がお勧めです。</p>

<h3>仕様</h3>

<p>CartはiOS7を入れたiPhone4s以上でご利用いただけます。</p>

<p><a href="https://itunes.apple.com/jp/app/cart/id883013201?mt=8&uo=4" target="itunes_store" style="display:inline-block;overflow:hidden;background:url(https://linkmaker.itunes.apple.com/htmlResources/assets/ja_jp//images/web/linkmaker/badge_appstore-lrg.png) no-repeat;width:135px;height:40px;@media only screen{background-image:url(https://linkmaker.itunes.apple.com/htmlResources/assets/ja_jp//images/web/linkmaker/badge_appstore-lrg.svg);}"></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ユーザビリティテストのタスクシート]]></title>
    <link href="http://taninno.github.io/blog/2014/02/01/usability-testing-template/"/>
    <updated>2014-02-01T20:10:16+09:00</updated>
    <id>http://taninno.github.io/blog/2014/02/01/usability-testing-template</id>
    <content type="html"><![CDATA[<p>ユーザビリティテストの進行やユーザーの行動などを記録するタスクシート（プロトコルのようなメモや議事録の雛形）を作成しました。ただユーザビリティテストを専門で行っているわけではないので、要素の抜け漏れなどはあるかもしれません。ユーザビリティのテストプラン作成やレポート作成、被験者のリクルーティングなどは参考情報をご参照下さい。<strong>ここではユーザビリティテスト全体ではなく、インタビュー中に使用するタスクシート（インタビューシート）に関してになります</strong>。</p>

<h2>2014/10/2 新しいタスクシート(ver2)を追記しました</h2>

<iframe width='850' height='600' frameborder='0' src="https://docs.google.com/spreadsheets/d/1kfyauniAyNH4JGfQcsAikfiDOcdknOMEs-SDcZEL7qk/pubhtml?gid=1818846745&amp;single=true&amp;widget=true&amp;headers=false"></iframe>


<h3>ver2の変更箇所</h3>

<ul>
<li>ver1ではフェイズ毎に別の列を記載していましたが、ver2では全て共通の列名を使用しています。列名がバラバラであったためスプレッドシートにしては複雑なレイアウトなっていました。今は列行は１つなので固定行にしてスクロール時にも見やすくなりました。</li>
<li>経過時刻を記載する列を追加しました。進行管理を行うときに遅れているのか進んでいるかのをすぐに把握するためです。</li>
<li>テストからの気付きを記載する「テスト結果の感想」列と、タスクを実施するための準備を記載する「準備・メモ」列を分けました。</li>
<li>達成や効率などの評価ポイントを自動で計算するようにしました。ちなみにこのポイントは数字が多いほどユーザーが躓いたことを表します。</li>
<li>13inchのMacBookでなるべく収まるように全体的に幅を短くしました。</li>
</ul>


<!-- more -->




<hr style="margin:25px 0;">




<iframe width='850' height='600' frameborder='0' src='https://docs.google.com/spreadsheet/pub?key=0ApZE_qOGDfNHdEYySkRNOGRBR0U0N2s3T2U0azJwelE&single=true&gid=0&output=html&widget=true'></iframe>




<br/><br/>


<h3>各ステップ ~ユーザビリティテストの構成~</h3>

<h4>1.アンケート</h4>

<p>リクルーティング時に被験者のリテラシーを全て把握していれば必要はありませんが、社内などの身近な方を対照するディスカウントユーザビリティテストなどではデモグラフィックのデータが揃っていないことが多いので、ここでセグメントを分類するためにアンケートを記載していただきます。このアンケートの目的はテストするサービスにどれだけ接点があるかです。<strong>利用頻度</strong>や<strong>サービスをどの程度まで理解</strong>されているかで、その後のテストの進め方にも影響します（例えば、実はハードユーザーであったのなら初心者向けタスクはスキップするなど）。もちろん外部や専門部署へリクルーティングを依頼する場合には、前もって設定したリテラシー範囲を挙げる必要があります。</p>

<h4>2.テスト前のお願い</h4>

<p>アンケートの後には、思ったことをそのまま口に出してもらう思考発話法の実践していただくようにお願いをします。ただし、ユーザビリティテストに慣れていない方にこのお願いをしても、すぐにはうまくいきません。そのためテストの最中に考えていること聞いて話を促しますので、<strong>わざわざ発話法に触れなくても良いと思います</strong>。そもそも発話法に慣れている方というのは被験者としてはあまり参考にならないかもしれません。他には被験者を評価しているわけではないことや、テスト中に質問されてもヒントになってしまう場合は答えられないことを伝えることが推奨されますが、儀式なようなものなのでアンケート後はすぐに状況説明をして良いと思います。</p>

<h4>3.状況説明</h4>

<p>いきなりプロトタイプ（スマフォやPC、またはペーパープロトなど）を渡すのではなく、感情移入しやすいようにテスト前の状況の経緯を伝えます。例えば、Webサイトのテストなら対象のサイトが表示された端末を渡すのではなく、「<strong>あなたはXXXが気になったので、GoogleでAと検索して、一番上に表示されたBというサイトをタップしました</strong>」と伝えてから始めます。こうすることで被験者がより自分の実体験に置き換えて実際の行動に近づけやすくなります。この状況はUXプロセスのストーリーで設計したシナリオを当てはめます。考えたシナリオは状況説明だけではなく、この後に行うテストにもシナリオがベースとなります。</p>

<h4>4.テストの実施</h4>

<p>テストのタスク内容もシナリオを流用します。ユーザビリティテストの実施を見越してシナリオの元になるプロット（<a href="http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/">http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/</a>）を作成しておくと良いかと思います。<strong>このようなユーザーのタッチポイントや操作順序、時間経過をまとめたプロット</strong>があればタスクシートの作成も簡単になります。</p>

<h4>5.質問（回顧法）</h4>

<p>テスト中に思った疑問を聞きます。インタビューアーの方ならテスト中でも「どうしてXXXを選択したんですか？」など聞きやすいですが、メモをとっていた人や別室でウォッチしている人は疑問をまとめて後で質問します。インタビューアーの方でもFive-Whysなどでコアな理由・原因を知りたいときにテスト後の時間を利用すれば、時間超過やタスクのヒントを言ってしまうことも防げます。また、サービスの全体的な印象を聞いたり、100満点で点数をつけてもらうときもここで行います。あとは逆に被験者からの質問・もやもやしていることを聞いたりします。</p>

<br/><br/>


<h3>タスクシートの項目について（ver1）</h3>

<p>下記の表の各列を左から説明します。</p>

<h4>タスク</h4>

<p>タスクの項番です。</p>

<h4>目安</h4>

<p>個々のタスクにかかる時間を記載します。ここでは分単位にしています。被験者によって大きくことなるので目安として設けています。</p>

<h4>優先度</h4>

<p>時間が足りなくなってきた際に、どのタスクをスキップすればいいのかを判断するために記載します。</p>

<h4>発言</h4>

<p>インタビューアーが被験者に質問する発言内容です。慌てても大丈夫なように台本のような見本となるセリフを記載します。ただし棒読みしてしまわないように自分なりの言葉に言い換えたほうが良いと思います。</p>

<h5>補足：インタビュー中のポイント</h5>

<ol>
<li>ユーザーが「～できるんですか？」と聞いてきたら「どう思います？」と逆に聞き返す。</li>
<li>ユーザーが思考発話でひとりごとを発している時には、「そうなんですね」とオウム返しをしてあげる。</li>
<li>ユーザーが少し戸惑っていたら、「どうしました？」と聞く。</li>
<li>ユーザーが操作を中断してしばらく経ったら、「～あたりに何かないですか？」とヒントを伝える。</li>
</ol>


<h4>ポイント</h4>

<p>当該タスクの目的を記載します。テストで確認したい箇所や着眼すべき箇所がどこなのかをハッキリさせます。</p>

<h4>想定する行動</h4>

<p>被験者の操作手順が最もベストだと思える操作を記載します。ここに記載する流れは既にシナリオで作成した内容になります。個人的にはユーザビリティテストで大切なことは個々のタスクの流れがシナリオ通りに進めているかを見つけ出すものだと考えています。</p>

<h4>実際の行動</h4>

<p>被験者がどのような操作や発言をしたのかを記載します。</p>

<h4>メモ</h4>

<p>記載者が個人的に気付いたことを記載します。被験者の発言からの発見やテストの改善など気になったことをメモする欄です。</p>

<h4>達成（効果/effctiveness）</h4>

<ul>
<li>◯はタスクを完了した場合</li>
<li>△はインタビューアーのヒントを得てタスクを完了した場合</li>
<li>☓はタスクを完了で来なかった場合</li>
</ul>


<h4>効率（efficiency）</h4>

<ul>
<li>◯は想定の操作通りにできた場合</li>
<li>△は多少迷っていた場合</li>
<li>☓は目安時間を超過した場合</li>
</ul>


<h4>満足（satisfaction）</h4>

<ul>
<li>◯は被験者が特に不満を持っていないと思われた場合</li>
<li>△は不満を持っていそうだと思われた場合</li>
<li>☓は不満を露わにしていた場合</li>
</ul>


<h4>評価（インパクト分析）</h4>

<p>達成・効率・満足を数値化してどの操作（タスク）が問題となっていたかを把握します。数値は一般的な優先順位付けではなく、重要度を測りやすくするため、数値が多いほど問題が大きくなるようにします。係数は以下の表の通りです。タスクが正常に完了すれば<strong>0</strong>、最も深刻な問題は<strong>12</strong>となります。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> &mdash;&mdash; </th>
<th align="center">  達成  </th>
<th align="center">  　効率  </th>
<th align="center"> 　満足</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">◯    </td>
<td align="center">    0   </td>
<td align="center">   0     </td>
<td align="center">   0</td>
</tr>
<tr>
<td></td>
<td align="center">△    </td>
<td align="center">    3   </td>
<td align="center">   2     </td>
<td align="center">   1</td>
</tr>
<tr>
<td></td>
<td align="center">☓    </td>
<td align="center">    5   </td>
<td align="center">   4     </td>
<td align="center">   3</td>
</tr>
</tbody>
</table>


<br/><br/>


<h3>参考情報</h3>

<h4>URL</h4>

<ul>
<li><a href="http://www.usability.gr.jp/">http://www.usability.gr.jp/</a></li>
<li><a href="http://www.usability.gr.jp/tag/usability-test/">http://www.usability.gr.jp/tag/usability-test/</a></li>
<li><a href="http://www.usability.gr.jp/whatis/standards/">http://www.usability.gr.jp/whatis/standards/</a></li>
<li><a href="http://www.usability.gov/">http://www.usability.gov/</a></li>
<li><a href="http://www.nngroup.com/reports/mobile-website-and-application-usability/">http://www.nngroup.com/reports/mobile-website-and-application-usability/</a></li>
<li><a href="http://www.nngroup.com/articles/ten-usability-heuristics/">http://www.nngroup.com/articles/ten-usability-heuristics/</a></li>
<li><a href="http://www.nngroup.com/articles/affordable_care_act_usability_issues/">http://www.nngroup.com/articles/affordable_care_act_usability_issues/</a></li>
<li><a href="http://ja.wikipedia.org/wiki/ISO_9126">http://ja.wikipedia.org/wiki/ISO_9126</a></li>
<li><a href="http://www.iid.co.jp/">http://www.iid.co.jp/</a></li>
<li><a href="http://directorblog.jp/archives/51780644.html">http://directorblog.jp/archives/51780644.html</a></li>
<li><a href="http://gigazine.net/news/20120830-ui-design-cedec2012/">http://gigazine.net/news/20120830-ui-design-cedec2012/</a></li>
<li><a href="http://www.coprosystem.co.jp/marketingblog/2012/01/24.html">http://www.coprosystem.co.jp/marketingblog/2012/01/24.html</a></li>
<li><a href="http://d.hatena.ne.jp/absj31/20120310/1331399198">http://d.hatena.ne.jp/absj31/20120310/1331399198</a></li>
<li><a href="http://www.userside.jp/evaluation/usability-test/index.html">http://www.userside.jp/evaluation/usability-test/index.html</a></li>
<li><a href="http://www.mitsue.co.jp/service/usability/web_usability_testing/">http://www.mitsue.co.jp/service/usability/web_usability_testing/</a></li>
</ul>


<h4>書籍</h4>

<ul>
<li><a href="http://www.amazon.co.jp/gp/product/4798112941/ref=as_li_tf_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4798112941&linkCode=as2&tag=copy-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4798112941&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=copy-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4798112941" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
<a href="http://www.amazon.co.jp/gp/product/4274201449/ref=as_li_tf_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4274201449&linkCode=as2&tag=copy-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4274201449&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=copy-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4274201449" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
<a href="http://www.amazon.co.jp/gp/product/4822296105/ref=as_li_tf_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4822296105&linkCode=as2&tag=copy-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4822296105&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=copy-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4822296105" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
<a href="http://www.amazon.co.jp/gp/product/4797339098/ref=as_li_tf_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4797339098&linkCode=as2&tag=copy-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4797339098&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=copy-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4797339098" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
<a href="http://www.amazon.co.jp/gp/product/4839922330/ref=as_li_tf_il?ie=UTF8&camp=247&creative=1211&creativeASIN=4839922330&linkCode=as2&tag=copy-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4839922330&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=copy-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4839922330" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.co.jp/gp/product/4798112941/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4798112941&linkCode=as2&tag=copy-22">ユーザ・エクスペリエンス ユーザ・リサーチ実践ガイド(IT Architects&#8217; Archive ソフトウェア開発の課題9)</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4798112941" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.co.jp/gp/product/4274201449/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4274201449&linkCode=as2&tag=copy-22">ユーザビリティエンジニアリング―ユーザ調査とユーザビリティ評価実践テクニック</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4274201449" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.co.jp/gp/product/4797339098/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4797339098&linkCode=as2&tag=copy-22">ウェブユーザビリティの法則 改訂第2版</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4797339098" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.co.jp/gp/product/4822296105/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4822296105&linkCode=as2&tag=copy-22">UXデザイン入門</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4822296105" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
<li><a href="http://www.amazon.co.jp/gp/product/4839922330/ref=as_li_ss_tl?ie=UTF8&camp=247&creative=7399&creativeASIN=4839922330&linkCode=as2&tag=copy-22">Webサイト設計のためのデザイン&amp;プランニング~ドキュメントコミュニケーションの教科書~ (Web Designing Books)</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=copy-22&l=as2&o=9&a=4839922330" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyperを使ったモックアップ主導のUI設計プロセス]]></title>
    <link href="http://taninno.github.io/blog/2013/09/12/justinmind-prototyper/"/>
    <updated>2013-09-12T23:28:00+09:00</updated>
    <id>http://taninno.github.io/blog/2013/09/12/justinmind-prototyper</id>
    <content type="html"><![CDATA[<p>ユーザーインターフェイスを設計する上で、主にモバイル向けのワイヤーフレームとモックアップ（プロトタイプ）の関係とモックアップツールに関することを記載しています。</p>

<br/>


<h3>UI設計はUXデザインプロセスの4段階目</h3>

<p>アプリやWebサービス、サイトなどを作っていく全体の流れは以下のプロセスを行っています。基本的なUXデザインのプロセス通りですが、<strong>コンセプトやアイディアの前に調査（理解）を重視している点</strong>と、<strong>ワイヤフレームではなくインタラクティブなモックアップを作成している点</strong>が多少異なるかもしれません。その他のプロセスにご興味がありましたら詳細は<a href="http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/">問題解決型UXデザインアプローチ</a>を御覧ください。</p>

<ol>
<li>理解</li>
<li>アイディア</li>
<li>ストーリー</li>
<li>UI</li>
<li>ビジュアルデザイン</li>
<li>開発</li>
<li>フィードバック</li>
</ol>


<p>今回は上記の中で画面の要素やレイアウトを検討する「UI」フェイズの「モックアップ」に関してを、整理していきながら記載していきたいと思います。<strong>このUIフェイズの目的は「ストーリー」で考えた要素をもとに、スケッチやモックアップを通して最終的に画面詳細設計書を作成することです</strong>。画面詳細設計書を作成するのは、基本的に受託UXなので、チーム・組織で活動するためにもドキュメントを成果物として考えていきます。</p>

<!-- more -->


<h4>一般的なUI設計プロセス</h4>

<p>多くの場合に採用されるUIの設計プロセスは恐らく以下の流れになるのかと思います。</p>

<ol>
<li>ワイヤーフレーム</li>
<li>画面詳細設計書（仕様書）</li>
</ol>


<p>ワイヤフレームは画面詳細設計書の中に含まれることが多いと思いますが、ステップとしてはまずワイヤフレームにあたる画面レイアウトを考える所から始めることが多いかと思います。又はワイヤフレームでの検証ステップもないまま、仕様書として画面詳細設計書に着手することあるかと思います。ただし、このプロセスではどのようなUIが出来上がるか想像しにくい欠点があります。</p>

<h4>モックアップ主導のUI設計プロセス</h4>

<p>建築でも必ず模型（モックアップ）で検証を行います。それに習い、効率を上げるために以下の設計プロセスを実践しています。</p>

<ol>
<li><strong>スケッチ</strong></li>
<li><del>ワイヤーフレーム</del></li>
<li><strong>モックアップ</strong></li>
<li>画面詳細設計書</li>
</ol>


<p><strong>モックアップ主導のUI設計プロセスで1番大切なのは、UIフェイズでなるべく早くにユーザビリティテストを行うことです</strong>。ユーザビリティテストなど、人の意見を聞くことが最も効率が良い設計方法だと考えています。そして、そのためにもモックアップの制作期間をなるべく短くし、ワイヤフレームではなく動的なモックアップを作成しています。</p>

<h4>ペーパープロトタイプでは不十分</h4>

<p>個人的にインタラクションが重視されるモバイルのUI設計では、静的なワイヤフレームやペーパープロトタイピングではなく、動的（操作可能・ハイフィデリティ）なモックアップの方がより適していると考えています。制作時の効率もそうですが、特にユーザビリティテストでの被験者の負担を軽くするためです。ワイヤフレームなどの静的な画面では、実際の画面との精度の差を想像しなければいけませんが、動くモックアップならスクロールができ、文字を入力することも画面遷移をすることも可能です。後で後述しますが、このハイフィデリティなモックアップ（プロトタイプ）を作成するのにJustinmind PrototyperとProto.ioが最も適していると考えています。</p>

<p>このようにペーパープロトなどのUIの開発手法が数多くあるため全てを行ってしまうと時間がかかってしまいます。そのためペーパープロトタイプとワイヤーフレームでの作業を削減することでモックアップに集中することでき、ユーザビリティテストまでの工数を短縮できます。</p>

<br/><br/>


<h3>スケッチやワイヤーフレーム、モックアップなどの用語</h3>

<p>モックアップに関して記載する前に、用語の語彙を整理したいと思います。モックアップやワイヤーフレーム、プロトタイプなどの言葉が何を意味するのかを、ここでは以下の意味で進めています。もしかしたら下記の定義は一般的な意味とは異るかもしれませんのでご参考までにお読み下さい。</p>

<h4><strong>スケッチ</strong>とは</h4>

<p>UIのレイアウトを考察するためのラフスケッチです。デッサンなどのラフスケッチと同じで、大まかな下書きとして何度も書き直したり、試行錯誤を繰り返します。スケッチでは細かな縦横比やサイズ感はあまり気にせずに、どこに何を配置するか、どのレイアウトパターンにするかを考えるためにあります。たくさんのレイアウトのパターンを書いたりするので紙と鉛筆で書くことが多くなります。<br/>
<img src="http://taninno.github.io/images/post/sketch.jpg" width="240"/><br/>
読書メモサービスHartのスケッチ例です。<br/>
<a href="http://hart.herokuapp.com">http://hart.herokuapp.com</a></p>

<br/>


<p><img src="http://taninno.github.io/images/prototyper/linowski.png" width="320"/><br/>
Linowski社が公開しているスケッチパターンのルールです。<br/>
<a href="http://www.linowski.ca/sketching.php">http://www.linowski.ca/sketching.php</a></p>

<br/>


<h4><strong>ワイヤーフレーム</strong>とは</h4>

<p>ワイヤーフレームはボタンなどのサイズや縦横比、レイアウトの構成やマージン値を実際のプロダクトレベルに近い精度で書き表したものです。出来上がったワイヤフレームは制作チームや関係者に渡すUIの設計図になります。場合によっては画面詳細設計書にワイヤフレームの寸法も記載することもあります。誤解されるかもしれませんが、スケッチとワイヤーフレームの違いは単純には精度（フィデリティ）だと思っています。紙と鉛筆で書いたとしてもボタンのサイズや比率、要素間の余白の扱い方がプロダクトレベルに近いものならワイヤフレームと言えると思います。<br/>
<img src="http://taninno.github.io/images/prototyper/wires-tablet.png" width="480"/><br/>
ワイヤーフレームのイメージ<br/>
Putting it All Together: Wireframing the Example App<br/>
<a href="http://developer.android.com/training/design-navigation/wireframing.html">http://developer.android.com/training/design-navigation/wireframing.html</a></p>

<br/>


<h4><strong>モックアップ</strong>とは</h4>

<p>ハリボテをあたかも実際に動いているように見せて画面の操作感や画面遷移を確認するものがモックアップです。ラピッドプロトタイプ,
使い捨てのプロトタイプとも言います。ここでのモックアップはラピッドプロトタイプの中でもハイフィデリティなものになり、ローフィディリティなペーパープロトタイプとは異なります。
<img src="http://taninno.github.io/images/prototyper/power.png" width="480"/><br/>
PowerPointでもボタンのリンクを設定することで簡易なモックアップが作成可能です<br/>
PowerMockupを使えばモックアップに必要なステンシルが利用できるので便利です<br/>
<a href="http://www.powermockup.com/">http://www.powermockup.com/</a></p>

<br/>


<h4><strong>プロトタイプ</strong>とは</h4>

<p>製品版と同じ技術を使用したプロダクトレベルで検証するものがプロトタイプです。ブレッドボード・プロトタイピングとも言います。モックアップとは違いハリボテで配置したボタンなどもプロトタイプレベルで作成します。例えばWebサイトでしたらHTMLやCSSで、AndroidならレイアウトXMLで宣言します。モックアップは主にUIの操作性の検証が目的でしたが、プロトタイプでは技術検証や非機能要件などの技術寄りの検証が目的になります。ソースコードがそのままプロダクトに流用されることもありますが、そのような場合にはアーキテクチャレベルでの議論も含める必要がでてくるので注意します。<br/>
<img src="http://taninno.github.io/images/prototyper/blend.png" width="480"/><br/>
Windows ストア アプリのプロトタイプ作成イメージ<br/>
Visual Studio 2013<br/>
<a href="http://www.microsoft.com/visualstudio">http://www.microsoft.com/visualstudio</a></p>

<br/>


<br/>




<div id="section1"></div>


<h2>1.スケッチ</h2>

<p>ここからは実際にスケッチからモックアップ、画面詳細設計書の各ステップで気をつけていることを自分なりに整理したいと思います。</p>

<h3>前提条件</h3>

<p>シナリオで検討したサービスの画面遷移と画面のレイアウトを考察します。シナリオではUIに関しては抽象的なことのみを記載していますので、具体的にどのような画面の流れで、どのようなインタラクションであればシナリオ通りになるかを考えていきます。最初に画面の全体構成を考えることはありますが、重要な各画面から考えていくこともあります。その際にはシナリオで提供したいサービスを明記し、スケッチの目的がアクセシビリティやユーザビリティのみを考慮したものにならないようにします。</p>

<h3>荒いスケッチ</h3>

<p><strong>Inspiring UI Wireframe Sketches</strong><br/>
<a href="http://webdesignledger.com/inspiration/inspiring-ui-wireframe-sketches">http://webdesignledger.com/inspiration/inspiring-ui-wireframe-sketches</a></p>

<p>スケッチはモックアップの前に行います。上記の記事のように多くの方が綺麗な画面を描かれる方もいますが、あまり綺麗すぎるスケッチは効果的ではないと考えています。わざと雑に描くことはないですが、FireworksやPhotoshopでパーツやステンシルを配置するのに時間をかけるのであれば、モックアップツール（プロトタイピングツール）で配置するのと時間は変わりません。同じボタンのパーツを配置しても、モックアップツールなら実機でタップできるボタンができあがります。モックアップツールの充実により、スケッチがUIのアイディアを考察することに集中することができます。</p>

<p><img src="http://taninno.github.io/images/prototyper/wf.png" width="240"/><br/>
画面を綺麗に描いてもUIの操作感は検証することができません。<br/>
Inspiring UI Wireframe Sketches<br/>
<a href="http://webdesignledger.com/inspiration/inspiring-ui-wireframe-sketches">http://webdesignledger.com/inspiration/inspiring-ui-wireframe-sketches</a></p>

<p>動くものを作らなくても、パワポやPhotoshopなどで作った画面をペーパープロトタイピングすることもありますが、できれば早い時期にスケッチでおおよそのイメージが掴めてきたら、それを検証するためにも操作可能なモックアップを作成すると良いと思います。ペーパープロトはスケッチ段階中であれば自分またはチーム間の確認のためには有効だと思いますが、ユーザーテストに使用するには被験者に慣れと画面を想像するスキルが求められることになります。<strong>ユーザーに試していただくためにもスケッチを手短にして早めにモックアップに着手することが効率が良いと考えています</strong>。</p>

<p><img src="http://taninno.github.io/images/prototyper/sketch.png"/><br/>
スケッチは綺麗に書かず、これくらいレベルでモックアップに着手します。<br/>
受諾UXアプローチ<br/>
<a href="http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/">http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/</a></p>

<br/>


<br/>




<div id="section2"></div>


<h2>2.モックアップ</h2>

<h3>ワイヤーフレームではなく、モックアップで検証する</h3>

<p>ワイヤーフレームの工程はモックアップやローフィデリティなプロトタイピングでまかなっています。動かないワイヤーフレームを書くよりは動くモックアップの方が精度の高いユーザビリティテストができるので、スケッチの後はワイヤーフレームではなくモックアップの作成を行っています。</p>

<blockquote><p>触れる・動くによって変わるデザインプロセス
<a href="http://www.yasuhisa.com/could/article/webdesign-and-prototyping/">http://www.yasuhisa.com/could/article/webdesign-and-prototyping/</a></p></blockquote>

<p>数年前まではモックアップを作るのにFlashやActionScriptなどのコードを書くことが必要でした。そのため工数が掛かってしまい、<strong>モックアップを作るためだけの予算が必要になったりしていました</strong>。このように気軽に試すことができないので、UIを議論するときにはワイヤーフレームを使うことが多くありました。けれども今はモックアップ専用ツールを利用することで、Flashよりも短期間で簡単に作ることができるようになりました。</p>

<p>UIを議論する場合にはハリボテとはいえ動くモックアップのほうがスムーズになります。ワイヤーフレームでは画面の流れやインタラクションを頭の中で動きを想像する必要があるため、実際の画面とイメージがかけ離れることがあります。</p>

<br/>


<br/>


<h3>ファーストビューのレイアウトではなく、操作中の状態を設計する</h3>

<p>画面のレイアウトを考える際にもワイヤーフレームでは最初にユーザーがディスプレイ上で閲覧するファーストビューだけで考えがちですが、ケータイよりもスクロールがしやすいスマフォのUIではコンテンツやボタンなどのコントロールを全てファーストビューに収める必要が少なくなります。ケータイでは十字キーの下を画面内のリンクの回数以上を押さないとスクロールしませんが、タッチUIのスマフォでは指を上にフリックするだけで画面の下にあるコンテンツが現れます。タッチUIの画面レイアウトで大切なのはファーストビューの周りに何のコンテンツを置き、ファーストビューにはそのコンテンツをどのように気づかせ、誘導するかが重要となります。</p>

<p><strong>ワイヤーフレームではファーストビューを意識するあまり、ユーザーが操作している状態を意識することが難しくなります</strong>。ワイヤーフレームはファーストビューのレイアウトを考えるのには有効ですが、現在はユーザーによる何かを操作している状態がどのように見えているかが重要になります。その都度の状態をワイヤーフレームで書き表すのは膨大になるため、モックアップを操作することで簡単に状態を再現、体験できます。この操作中の状態がどのように見えるのかは、実際にやってみてみるとワイヤーフレームやペーパープロトタイプ以上の発見があります。ワイヤーフレームなどの静的な情報から操作中を想像するのはUIデザイナーでないと難しいですし、考慮漏れが出てきてしまいます。</p>

<p>動的なモックアップはワイヤフレームを作るより大変ですが、このレベルでの画面操作を盛り込むことで、早期に実際の製品にとても近い操作でユーザーテストを実施することができます。実機で操作できますので、<strong>特にモバイルではスマートフォンのタップしやすい領域内にボタンがあるかなどを体感できます。さらに、スクロールする情報量の確認やスクロール後の位置がタップしやすいかなどの基本的なUIの検証を行います</strong>。これらの操作感はペーパープロトタイプでは実感しづらく、ワイヤーフレームやプロトタイピングなどの少し工程が進んだ時では、間違いに気付いたとしても手戻りが多くなってしまいます。なにより、モックアップの作成コストがPowerPoint感覚まで下がってきているので、モックアップを作りやすい環境が整ってきています。</p>

<br/>


<br/>


<h3>たくさんのモックアップツール</h3>

<p>ここで記載していますモックアップツール（またはプロトタイピングツール）は、下記の3.と4.を作成するためのツールになります。</p>

<p>低精度（ローフィデリティ）<br/>
↑</p>

<ol>
<li>紙などに手書きするスケッチ → 画面のアイディアを考察するため</li>
<li>ペーパープロトタイプ → 専門チーム内でのインタラクションの共通理解のため</li>
<li>一枚絵のモックアップ → ビジュアルを含めたインタラクションの早期確認のため（POP, Flinto）</li>
<li>操作可能なモックアップ → UIの操作性の検証とUXの実現可能性を検証するため（Prototyper, Proto.io, UXPin）</li>
<li>ソースコードから作るプロトタイプ → 技術検証や非機能要件の検証のため</li>
</ol>


<p>↓<br/>
高精度（ハイフィデリティ）</p>

<p>プロトタイプツールと言ったりもしますが、5.を指すわけでなく、3.と4.にあたります。ややこしい言い方になってしまいますが、モックアップツールとプロトタイピングツールは同じものを指します。それはプロトタイプをブレッドボード・プロトタイピングと定義しているため、プロトタイプを作るにはIDEなどの本番の開発環境を用いるためです。</p>

<blockquote><p>Designer’s Toolkit: Road Testing Prototype Tools
<a href="http://www.cooper.com/journal/2013/07/designers-toolkit-proto-testing-for-prototypes">http://www.cooper.com/journal/2013/07/designers-toolkit-proto-testing-for-prototypes</a></p></blockquote>

<p>アラン・クーパーさんのブログでモックアップツールを紹介する記事がありますが、比較されている10個のツールうち、インタラクションの項目がHighなのは2つだけです。その1つが後述しますPrototypers(<a href="http://www.justinmind.com/">http://www.justinmind.com/</a>)になります。</p>

<p><img src="http://taninno.github.io/images/prototyper/summaryChart.png" width="520"/><br/>
<a href="http://www.cooper.com/journal/2013/07/designers-toolkit-proto-testing-for-prototypes">http://www.cooper.com/journal/2013/07/designers-toolkit-proto-testing-for-prototypes</a></p>

<br/>


<br/>


<h4>POP</h4>

<p>POPはiPhoneとAndroidで配信されているアプリです。紙に書いた画面をPOPで撮影し、アプリ内で画面を繋げていくと、紙に書いた画面が端末で操作可能になるというツールです。まだUIを考え始めたスケッチ段階で手軽にできるので助かります。<br/>
<img src="http://taninno.github.io/images/prototyper/pop.png" width="240"/><br/>
<a href="https://popapp.in">https://popapp.in</a></p>

<h4>Flinto</h4>

<p>Flintoは画面（PNGなど）を配置し、画面遷移する場所を指定するだけで実機上で操作可能なアプリ（モックアップ）が作成できます。画面はPhotoshopなどで作成するので主にUIデザイナーの方が利用される場合に便利だと思います。2014年にAndroid端末にもインストールできるようになりました。<br/>
<a href="https://www.flinto.com/">https://www.flinto.com/</a></p>

<h4>Prototyper</h4>

<p>PrototyperはJustinmind社によるモックアップツールです。インタラクション性の高いモックアップツールにはproto.ioなどのWebブラウザ型が多いですが、Prototypeはスタンドアローンのデスクトップアプリなのが特徴です。製品名にはプロトタイプ（“prototype”）が含まれていますが、製品に近い技術で作成されるプロトタイプというよりは、動きやコンポジションなどを確認するモックアップに近いです。<br/>
<img src="http://taninno.github.io/images/prototyper/device.png" width="240"/><br/>
<a href="http://www.justinmind.com/">http://www.justinmind.com/</a></p>

<h4>proto.io</h4>

<p>proto.ioは主にモバイル向きの多機能系のモックアップツールです。入力可能なテキストフィールドやテンプレー機能など、ワイヤフレームレベルの画面を制作することができます。HTML出力などができないですが無料プランもあります。ちなみに上記の表の中でインタラクションの項目がHighだったもう１つがこのproto.ioです。（ただしWebブラウザ上で動作するため、個人用途では便利ですが、受諾制作などではPrototyperなどのデスクトップアプリケーションの方が好ましいかもしれません）<br/>
<img src="http://taninno.github.io/images/prototyper/protoio.png" width="240"/><br/>
<a href="http://proto.io">http://proto.io</a></p>

<h4>UXPin</h4>

<p>UXPinというWebブラウザ上で動作するツールも使いやすいのですが、こちらは有償プランのみになります。ただペルソナのテンプレートが用意されているなど、他のツールにはないUXワークフロー全般のサービスがあります。
<img src="http://taninno.github.io/images/prototyper/uxpin.png" width="480"/><br/>
<a href="http://uxpin.com">http://uxpin.com</a></p>

<h4>pentotype</h4>

<p>pentotypeはモックアップ（プロトタイプ）ツールではなくスケッチ用途ですが、iPadで簡単に画面レイアウトを描くことができます。画面遷移も設定できるため、その場でスケッチしたUIの流れを把握することができます。ちなみに、pentotypeのUIはとても綺麗です。<br/>
<a href="http://www.pentotype.com/">http://www.pentotype.com/</a></p>

<br/>


<br/>


<h3><strong>Prototyper</strong></h3>

<p>そのたくさんあるツールの中でモックアップを作成するにはPrototyperが最も適していると思います。先にモックアップは操作（スクロールやタップ、入力など）ができることが重要と記載しました。<strong>そのようなインタラクション性が高いモックアップを作れるのはPrototyperとproto.ioになります</strong>。proto.ioも非常に使い易いモックアップツールなのですが、proto.ioはWebサービスであるため、オフラインや機密が高い環境でも作業できるPrototyperを使用しています。もちろんPOPやFlintoなどのツールがダメなわけはありません。POPはローフィディリティなUIからでもイメージするスキルがある、例えばUIデザイナーやインタラクションデザイナーなど方であれば便利なツールだと思います。又、FlintoはPhotoshopのスキルを持っているデザイナーの方には最適なツールだと思います。</p>

<h4>iPhoneやAndroidなどのUIコンポーネントが豊富</h4>

<ul>
<li><a href="https://www.justinmind.com/usernote/tests/4/1765/11188319/index.html">iOS7</a></li>
<li><a href="https://www.justinmind.com/usernote/tests/4/1765/11398971/index.html#/screens/d12245cc-1680-458d-89dd-4f0d7fb22724">Android 4.4</a></li>
<li><a href="https://www.justinmind.com/usernote/tests/4/1765/10341535/index.html">Windows8</a></li>
<li><a href="http://www.justinmind.com/usernote/tests/4/1765/10099572/test/screens/Windows%207%20Phone%20Library.html">Windows Phone</a></li>
</ul>


<p><img src="http://taninno.github.io/images/prototyper/ios7_component.png" width="320"/>
<img src="http://taninno.github.io/images/prototyper/andoroid_component.png" width="320"/></p>

<h4>操作可能なUIコンポーネント</h4>

<p>ボタンやテキストフィールドなどのコンポーネントを操作可能な状態の画面をスマートフォンなどの実機で操作することができます。テキストフィールドコンポーネントに実際に文字入力が可能です。<br/>
<img src="http://taninno.github.io/images/prototyper/input.png" width="240"/></p>

<p><a href="http://blog.justinmind.com/justinmind-at-google-glass-san-francisco/">Google Glassのウィジェット</a>も用意されるらしいです。</p>

<p><img src="http://taninno.github.io/images/prototyper/googleglass.png" width="240"/></p>

<h4>モバイルへの実機プレビューが簡単</h4>

<p>PrototyperはQRコードを出力して簡単に実機でモックアップを操作することができます。</p>

<h4>ドキュメントの出力</h4>

<p>PrototyperではさらにWordやPDFへの画面仕様書の自動出力機能があります。仕様書に載せる画面はツールから出力したものを使用します。手戻りがあっても画面仕様書の反映作業が大幅に短縮できます。Wordのフォーマットも自分でカスタマイズできます。ただし、<strong>１枚の用紙におさまるように出力されてしまい、スマフォなどの縦に長い画面では縮小されてあまり閲覧性がよくありません</strong>。そのため、面倒ではありますが各画面を画像ファイル出力し、それをExcelに１シートに１画面を配置して画面仕様書を作成しています。</p>

<p><img src="http://taninno.github.io/images/prototyper/word.png" width="240"/><br/>
出力する画面を選択してるところです</p>

<h4>欠点</h4>

<p>ハッキリ言ってPrototyperは細かくインタラクションが設定できる分、制作者のツールスキルが求められます。PrototyperのUIはPhotoshopなどのデザインツールやAxureなどのモックアップツールに似ていますが、全く同じというわけではなく、ツール自体もそこまで使いやすいわけではありません。どこになにがあるか、何をしたら実現できるのかなど、慣れるまで若干時間が掛かるかと思います。<strong>ある意味プロフェッショナル向けであるため、UIデザイナーの方以外が無理して使う必要はありません。POPやFlinto、グットパッチ社のProttなどのツールでも効率よくUI設計ができます。</strong></p>

<p>Prototyperのサイトにはチュートリアルや逆引きTips、ヘルプ、サンプルファイルが掲載されていますので、こちらをもとに最初は慣れていくしかありません。</p>

<blockquote><p>Learn how with video tutorials<br/>
<a href="http://www.justinmind.com/prototyper/learn-build">http://www.justinmind.com/prototyper/learn-build</a><br/>
Download free example prototypes and test them online<br/>
<a href="http://www.justinmind.com/prototyper/examples">http://www.justinmind.com/prototyper/examples</a></p></blockquote>

<p>又は、Tipsを記載していますので、こちらをご参考下さい。<br/>
<a href="#section4">Prototyper Tips</a></p>

<br/>


<br/>


<h3>今後の新しいモックアップ</h3>

<p>モックアップ重視のプロセスは工数を低減することが目的でした。今後はさらに作業効率を上げるため、途中成果物である模造品としてのモックアップではなく実際の製品レベルに近いプロトタイプを簡単に作れる環境が今後普及すると思われます。</p>

<h4>Create a responsive wireframe</h4>

<p>HTMLなどの知識があるコーダーの方であれば、Prototyperなどのモックアップツールではなく、HTMLを作成すればより早く開発に着手することができ、さらに工数を短縮できます。<br/>
<img src="http://taninno.github.io/images/prototyper/responsive.png" width="240" /><br/>
<a href="http://www.creativebloq.com/javascript/create-responsive-wireframe-3133034">http://www.creativebloq.com/javascript/create-responsive-wireframe-3133034</a></p>

<h4>stand in</h4>

<p>Photoshopなどのデザインツールに慣れている方は、Photoshop上でから実機で確認ができるインタラクティブなモックアップを作成することができるようになります。これによりUIフェイズと、さらにビジュアルデザインフェイズも短縮できます。<br/>
<img src="http://taninno.github.io/images/prototyper/stand.png" width="320" />  <br/>
<a href="http://standin.io/">http://standin.io/</a></p>

<br/>


<br/>




<div id="section3"></div>


<h2>3.画面詳細設計</h2>

<p>モックアップでユーザビリティテストなどの検証を何回か行った後に画面詳細設計書の作成に入ります。スケッチやモックアップを何回やり直せるかは予算とスケジュール次第ですが、画面詳細設計に着手する段階でそれなりに自信があるUIが設計していることとします。これが小規模案件であれば画面詳細画面書からやり直したり、そもそも設計書を記載せずに開発フェイズに着手しても良いと思います。もっと言えば個人やベンチャーならモックアップではなくプロダクトレベルのプロトタイプを作成することで、より期間を短縮できます。ですが、ここでは受諾型UXプロセスにより、成果物としてのUIに関するドキュメントを作成することを考えたいと思います。</p>

<p>PrototyperのWordやPDFへの出力機能から自動で作成すること可能です。ただし、モバイルやコンテンツ量が多いWebですと画面が縦長となってしまい、Wordなどでは見やすくありません。それに相手の環境に依存しないことが求められます。そのため、Prototyperから各画面を画像ファイルで書き出し、Excelに配置するようにしています。Excelであれば縦長の画面を見るのも比較的簡単です。組み込みやスクロールの概念がないUIであればPowerPointを使用します。Illustratorなどのデザインツールも検討しましたが、管理保守するさいにインストールされていることが必要なため、普及しているOfficeで作成しています。できればPrototyperの出力機能が改善されるか、新しいモックアップツールが登場するのが良いのですが、今現在ではExcelを使用するのが良いと考えています。</p>

<p>そのExcelでは複数のシートを分けて管理します。始めにview_listシートで画面一覧を記載し、個々の画面は１つのシートに１画面を配置します。必要があれば汎用ボタンや共通アイコンのシートを作成します。画面遷移図のシートも作成することがありますが、これはキャンバスが広い方が便利なので、画面数に酔っては他のツールを利用することもあります。</p>

<br/>


<br/>




<div id="section4"></div>


<h2>Prototyper Tips</h2>

<p>Prototyperに関するTipsを引用しています。</p>

<!-- Place this tag in your head or just before your close body tag. -->


<script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>




<!-- Place this tag where you want the widget to render. -->


<div class="g-post" data-href="https://plus.google.com/107539786331492217195/posts/Avb5MG6uQAX"></div>




<!-- Place this tag where you want the widget to render. -->


<div class="g-post" data-href="https://plus.google.com/107539786331492217195/posts/NsU7JwH1NW2"></div>




<!-- Place this tag where you want the widget to render. -->


<div class="g-post" data-href="https://plus.google.com/107539786331492217195/posts/XeUyNu4Yxyp"></div>




<!-- Place this tag where you want the widget to render. -->


<div class="g-post" data-href="https://plus.google.com/107539786331492217195/posts/JiK8Gojab94"></div>




<!-- Place this tag where you want the widget to render. -->


<div class="g-post" data-href="https://plus.google.com/107539786331492217195/posts/4WSaYQyqhGn"></div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[問題解決型UXデザインアプローチ]]></title>
    <link href="http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/"/>
    <updated>2013-05-16T12:43:00+09:00</updated>
    <id>http://taninno.github.io/blog/2013/05/16/my-ux-design-approach</id>
    <content type="html"><![CDATA[<p><img src="http://taninno.github.io/images/post/ux.png"/></p>

<p>受託のUXデザインを進めていく中で作業の流れと自分が心掛けていることを記載しています。基本的なプロセスはHCDやデザイン思考とあまり変わりませんが、ウォータフォールのような受諾型のためドキュメント指向のコミュニケーティングデザインを行いやすいように独自に実践している内容になります。特に<strong>ここでのUXは受託開発で多い問題解決型のUXを扱うため、最近ではむしろ主流とされている顧客開発型のUXとは多少異なります</strong>。また内容は随時更新しています。</p>

<h4>問題解決型UXのデザインプロセス</h4>

<ol>
<li><a href="#section1">理解</a></li>
<li><a href="#section2">アイディア</a></li>
<li><a href="#section3">ストーリー</a></li>
<li><a href="#section4">UI</a></li>
<li><a href="#section5">ビジュアルデザイン</a></li>
<li><a href="#section6">開発</a></li>
<li><a href="#section7">フィードバック</a></li>
</ol>


<!-- more -->


<h4>参考手法</h4>

<ul>
<li>ゴールダイレクテッドデザイン

<ul>
<li>About Face 3 インタラクションデザインの極意</li>
<li><a href="http://hart.herokuapp.com/public/user/yk/book/39">http://hart.herokuapp.com/public/user/yk/book/39</a></li>
</ul>
</li>
<li>コミュニケーティングデザイン

<ul>
<li>Webサイト設計のためのデザイン&amp;プランニング</li>
<li><a href="http://hart.herokuapp.com/public/user/yk/book/46">http://hart.herokuapp.com/public/user/yk/book/46</a></li>
</ul>
</li>
<li>コンテキスチュアルデザイン

<ul>
<li>Contextual Design: Defining Customer-Centered Systems</li>
</ul>
</li>
<li>ワンページデザイン

<ul>
<li>シムシティ</li>
<li><a href="http://www.ea.com/sim-city">http://www.ea.com/sim-city</a></li>
</ul>
</li>
<li>Lean UX

<ul>
<li>Janice Fraser</li>
</ul>
</li>
<li>HCD/UCD

<ul>
<li><a href="http://www.hcdnet.org/">http://www.hcdnet.org/</a></li>
</ul>
</li>
</ul>


<br/>


<br/>




<div id="section1"></div>


<h3>1.理解</h3>

<p><img src="../../../../../images/approach/01.jpg" />
まずは課題（既知の問題や新規サービス）に対して、現在置かれている状況、展望、分析を行い、対象ドメインを理解したら、その人はどうされたいのか？を考えて、情報を蓄積し整理し続けていくと次第に「こうすればいい」というアイディアが生まれてきます。そして、それをコンセプトにします。このように理解していく中で生まれたアイディアを元に進めていきます。<strong>他のデザインプロセスと最も異なるのはこの理解（インプット）に時間をもっとも掛けるところだと思います</strong>。多くのプロセスでは分析とアイディアは別の段階として分けられていますが、本プロセスでは理解Phaseの中にアイディア自体を含めています（ただ異なると言ってもfrog designのように現地調査に多くの時間を掛ける方法を実践されているところは沢山あります）。上記のUXプロセスの流れでは理解Phaseがアイディアを思い付くためにあるのと、アイディアPhaseがアイディアの可視化のためのフェイズというように、インプットとアウトプットで段階を分けているだけになります。</p>

<h4>目的</h4>

<p>ニーズや要件、問題点、環境、事情を理解し、アイディアを見つける。</p>

<h4>順序</h4>

<ol>
<li>クライアントとのヒアリング</li>
<li>顧客調査（業界調査・競合調査・ポジショニングマップ・4P分析・SWOT分析など）</li>
<li>ビジネスゴールの設定</li>
<li>ユーザ調査（定量的なアンケートからユーザーインタビューまで）</li>
<li>ユーザーゴールの設定</li>
<li>ペルソナの作成*</li>
<li>既存ユーザーのジャーニーマップの理解*</li>
</ol>


<h4>作業</h4>

<h5>1-1.クライアントとのヒアリング</h5>

<ul>
<li>最初に話を聞く時間をなるべく沢山とる。表向きのビジネスゴールのようなものから本音の社内ゴールや夢や愚痴などを出来る限り聞く。</li>
<li>最初にヒアリングとして2時間くらいの打ち合わせを設けるが、2時間ぐらいでは表層の部分の問題しか聞くことができない。ましてやNDAを結んでいるとはいえ、初対面の人には言い辛いことも多い。社内政治的な原因であればなおさら話せない。そういった問題はある程度親密でなければ難しい。私はこの聞き出すスキルが足りてないので感覚的に16時間以上くらい（週1回の2時間MTGの頻度であれば2ヶ月後）話を聞かないと本当の問題を理解できるようにならない。</li>
</ul>


<h5>1-2.顧客調査</h5>

<ul>
<li>マーケティングのフレームワークなどが数多くあるので既に作成されているのであれば共有してもらう。特に数字はROIで目標達成のために必要になるので集取する。</li>
</ul>


<h5>1-3.ビジネスゴールの設定</h5>

<ul>
<li>カスタマーエクスペリエンスといったビジネス必要な情報、KPIやROIを理解することで後に生まれるアイディアがより具体的になる。その会社や組織、チームの特徴を活かしたアイディアにする。相手のことを理解しないで考えると、思いついたアイディアが競合他社でも成り立つアイディアになってしまう。もちろんそういうアイディアでも提案するが、それは今の会社からどれくらい離れいてることなのかを覚悟して言うのとでは、ただの突拍子もない意見に聞こえてしまう。</li>
<li>ビジネスモデルキャンバスを利用するのも良い。</li>
</ul>


<h5>1-4.ユーザ調査</h5>

<ul>
<li>実際のユーザーからのフィードバックや要望や苦情に目を通して、可能であれば対面でインタビューを行う。既にアンケートを実施している会社もあるが、実際にアンケートを参考されることも少ない。できれば生の意見があったほうがいい。</li>
<li>本来はユーザーに対して調査を行いたいが、時間がなければ社内のユーザーに聞いてみるもの有効だと考える。不満やアイディアは意外と多くの人が持っていたりする。そういった人たちに話を聞いてみるものUXデザインをする人の役割だと考える。</li>
</ul>


<h5>1-5.ユーザーゴールの設定</h5>

<ul>
<li>エンドユーザーであったり、既存のサービス内容であったり、受託UXならクライアントであったりを理解する。その人の気持ちを理解してその人になりきる。</li>
<li>ユーザーのニーズから直接的にゴールを設定しない。それでは対処療法的になってしまうので、新しい問題が出た時に、又は隠れた問題が合った際につじつまが合わなくなってしまう。なので、アイディアをコンセプトが複数の問題を解決する、という形にする。</li>
<li>UX受託の問題解決型なら「解決」することを考えて、顧客開発なら「自分が嬉しい」ことを考える。</li>
</ul>


<h5>1-6.ペルソナの作成 ＊（以下オプションにアスタリスクを付与）</h5>

<ul>
<li>もしペルソナを作っていたら普段から意識するために壁に貼り、常に見えるようにしておく。</li>
<li>個人的にはあまりペルソナのキャラクターを細かくしないほうが良い考える。又はフェイクペルソナを作るぐらいであればペルソナ自体を作らなくても良いと思う。ペルソナを作る目的はサービス提供者側がユーザーをもっと近くに意識するためにあると思う。細かいキャラクター設定をしたペルソナがあってもあまり説得力を持たない。

<ul>
<li><img src="http://taninno.github.io/images/post/persona.png" width="380" /></li>
<li>ペルソナで記載する最小プロパティ

<ul>
<li>簡単なシルエット写真</li>
<li>氏名（ニックネーム）</li>
<li>年齢（年代）</li>
<li>職業（業種単位）</li>
<li>既存サービスとのタッチポイント</li>
<li>既存サービスの利用頻度</li>
<li>既存サービスの利用目的</li>
<li>既存サービスのリテラシー</li>
<li>既存サービスへの要望</li>
</ul>
</li>
</ul>
</li>
<li>少ないキャラクター説明では理解されにくかったらポジショニングマップを添えると良い。ただ分かりやすいことでかえって問題も単純し過ぎてしまわないようにする。2軸のポジショニングマップは軸の選択と項目の配置が難しいため、参考程度の簡易的な資料と捉えたほうがいい。</li>
<li>できればLeanのように実際のユーザーをペルソナにしたほうが早く、納得もしやすい。ただそういったパートナーを見つけるのが難しければ簡単なペルソナを作り、サービスを作る目的がユーザーのためなのだと、思い返すために用意しておく。</li>
</ul>


<h5>1-7.既存サービスのジャーニーマップの理解 ＊</h5>

<ul>
<li>サービスの内容を理解し始めると、ユーザーとサービスの関わり方を一日の流れの中で図式する。これをジャーニーマップやUXマップなどに含まれるかもしれない。書いている途中でこのサービスでいいのかな？もっと先に提供すたほうがいいかな？と直したいところが出てくる。それは後々のアイディアに繋がってくるので違う色で囲ってメモしておく。</li>
<li>ここでのジャーニーマップは簡易的なスケッチであり、紙と鉛筆でアイディアを使用した場合のペルソナを行動させてみて、１日ないしサービスの適用期間内の問題点を見つけ出す作業である。プロットの前段階で行う。</li>
</ul>


<h4>成果物</h4>

<ul>
<li>業界調査</li>
<li>競合調査</li>
<li>ポジショニングマップ</li>
<li>ビジネスゴール</li>
<li>ユーザーやクライアントのメンタルモデル</li>
<li>ユーザーゴール</li>
<li>ペルソナ*</li>
<li>既存サービスのジャーニーマップ*</li>
</ul>


<h4>備考</h4>

<ul>
<li>アイディアを考えようとするのではなく問題の中にアイディアがある。だから問題や関係する人や環境を問診して、ずっとみていればいずれアイディアが出てくる。そういう意味では理解フェイズの時点でアイディアを考えて、アイディアフェイズはアイディアを視覚化するだけでもいい。</li>
<li>ヒアリングをしている段階でアイディアを思いついたり、ユーザー調査をしているときにジャーニーマップが書けてたり、ペルソナを作っているときにUIが浮かんできたり、先のフェイズの成果物が思いつくことはよくあり、良いことだと思う。あまり進行フローに囚われず場合によっては中間の作業も包括した成果物が作成可能であればスキップすることも場合によってはあったりする。</li>
</ul>


<br/>




<div id="section2"></div>


<h3>2.アイディア</h3>

<p><img src="../../../../../images/approach/02.jpg" />
理解Phaseで見つけたアイディアをチーム（制作チームからステークホルダーなど）内で方向性を一致させることが目的になります。そのための方法としてコンセプトを分かりやすく可視化します。理解Phaseで見つけたばかりのアイディアはまだフワフワとしています。言葉も抽象的なままです。<strong>アイディアを相手に伝えるために考えるのがこのPhaseです</strong>。アイディアを考えるPhaseではありませんし、アイディアを考えようと思っても生まれるものではありません。ちなみにこの方法は問題解決型特有の方法だと思います。課題に対して関係する情報を集めて対処するのが基本的なアプローチです。ユーザーの新しいニーズを掘り起こす顧客開拓型やLeanStartUpとは考え方が異なります。</p>

<p><img src="http://taninno.github.io/images/post/concept.png" width="320"/></p>

<h4>目的</h4>

<p>アイディアを可視化し、方向性を共有する。</p>

<h4>順序</h4>

<ol>
<li>ブレストを開催する</li>
<li>アイディアを考える</li>
<li>コンセプトに作る</li>
<li>ビジョンを書く*</li>
</ol>


<h4>作業</h4>

<h5>2-1.ブレストを開催する</h5>

<ul>
<li>調査フェイズをやっていると個人個人でアイディアのネタを持ち始める。それをお披露目するためにブレストを行う。</li>
<li>ブレストなので関係者を集めて自由にディスカッションする。</li>
</ul>


<h5>2-2.アイディアを考える</h5>

<ul>
<li>ブレストをしてアイディアが集まったら、ビジネスゴールとユーザーゴールを両立するアイディアにしていく。</li>
<li>ビジネスゴールとユーザーゴールのどちらかしかなければ、またブレストのやり直しか調査フェイズの成果物を読み直しを行う。</li>
<li>考える問題の範囲を広くする。画面のUIだけで完結するのか？どこまでを変更すればいいのか？ユーザーの環境、考え方までを、受託でやることなの？ってぐらいまでを問題対象として広く考える。場合によってはちゃぶ台をひっくり返す。場合によってはここでサービス撤退さえも判断の対象となる。</li>
</ul>


<h5>2-3.コンセプトに作る</h5>

<ul>
<li>完璧だと思うアイディアが生まれたら可視化する。</li>
<li>コンセプトは絵や図、文章などその時に合いそうな表現にする。最近はアジャルのエレベーターピッチのように文章がブーム。電通のディレクターがやるようなラブレターのようなものでいい。けれどコンセプトは共有するためにあるので、分かりやすいものにする。必要があればインフォグラフィックにしてもいいかもしれない。</li>
<li>コンセプトはデザインブリーフのようにUXの方向性をチーム間で共有してブレないようにするためにある。なので作ったコンセプトは壁に貼っておく。シムシティのデザインアプローチを参考にする。</li>
</ul>


<h5>2-4.ビジョンを書く ＊</h5>

<ul>
<li>コンセプトはサービス内容を分かりやすく伝えるものだが、なぜそのサービスを提供するのか？そもそもなぜ提供するのか？などのもっと根本の部分を明記する。</li>
<li>当たり前のようになりがちだが、後のフェイズで方向性は常にブレる。その時のために前提となる価値観を共有するために事前に作成しておく。</li>
<li>既存のサービスにもユーザーに対してより良くしたいという想いがあって始めていることが多いと思う。理想的にも伝わりがちだが、達成したい想いがなければモチベーションを維持するのが難しくなる。もしビジネスゴール寄りの儲かるなどの利益を追求するだけであればUXアプローチである必要はなくなる。広告や広報にフォーカスすればいい。</li>
</ul>


<h4>備考</h4>

<ul>
<li>プロジェクト用の情報共有サイト（JIRAやBasecampなど）があるなら作成したアイディアなどを掲載する。コンセプトはトップページに配置するぐらいに。</li>
<li>以前はコンセプト後に要件定義フェイズを置いていたが、要件定義は機能要件を暗に含むことが多く、誤解を生みやすい。そのため要件定義は具体的なサービス内容が見えてくるストーリーフェイズの最終成果物とする。</li>
</ul>


<h4>用語</h4>

<ul>
<li>アイディア
: 相反しやすいビジネスゴールとユーザーゴールを両立させる解決策や戦略</li>
<li>コンセプト
: アイディアを分かりやすくキャッチコピーにしたもの</li>
<li>ビジョン
: ゴールを達成させたい気持ちを表した組織の目指すべきものを表したもの。ミッションまで記載するとややこしくなるので厳密には分けない。狭義の意味では先の「感動を伝えたい」はミッション的だがビジョンとしてまとめて記載している。</li>
</ul>


<br/>




<div id="section3"></div>


<h3>3.ストーリー</h3>

<p><img src="../../../../../images/approach/03.jpg" />
ユーザーに対して実際にどのようにしてゴールまで辿り着くかの流れを書き起こし、抽象的なコンセプトを具体的なサービス内容に落としこむPhaseです。考えたアイディアが提供するサービスは、<strong>実際にユーザーに対してどのようなメリットを与えるのかをサービスの前後の時間軸に沿って可視化していきます</strong>。</p>

<h4>作業内容</h4>

<p>アイディアをシナリオによってサービス内容を具体化する。</p>

<h4>順序</h4>

<ol>
<li>プロットを構成する</li>
<li>シナリオを書く*</li>
<li>ジャーニーマップを描く*</li>
<li>ストーリーボードを描く*</li>
<li>機能要件をまとめる</li>
</ol>


<h4>作業</h4>

<h5>3-1.プロットを構成する</h5>

<ul>
<li>この時にはもうアイディアあり、場合によっては実装しているかもしれない。ただアイディアだけではサービスを構成するには不十分で、もっとサービスを膨らませるためにアイディアをペルソナに当てはめた１日（又は数年でも）を表にまとめる。</li>
<li>ユーザー（ペルソナ）が１日、もしかしたら数年を見越してそのサービスを使うことでメリットが何かを書き起こす。</li>
<li>アイディアが効果を持つのはピンポイントなことも多いので、ペルソナの1日をイメージしながら考えると、朝はこうするかもしれない！とか、ここでXXXが無い！などのジャーニーマップでは抽象的過ぎて気づかなかった点を思い起こさせる。</li>
<li>アイディアを膨らませて具体的なサービスにする。時間の流れの中でどこにサービスしたらいいかを考える。問題が出たり、しっくりこなかったらアイディアを考えなおす。</li>
<li>機能要件でまとめる具体的なサービスはここで現れてくる。</li>
<li>コンセプトが終わり、よし明日からシナリオを考えるぞ、ということにはならない。アイディアとシナリオは明確に区切れてるわけではなく、成果物として別であるだけある。アイディアを考えたらスイッチを入れ替えてすぐにシナリオに落としこむ。どんなシナリオも生まれる万能なコンセプトなんてものはない。

<ul>
<li><img src="http://taninno.github.io/images/post/plot.png"/></li>
</ul>
</li>
</ul>


<h5>3-2.シナリオを書く ＊</h5>

<ul>
<li>プロットを小説にしたものがシナリオになる。文章だけではなく、視覚化したジャーニーマップに含ませたり、4コマ漫画風にしたストーリーボードにしてもいい。どのアウトプットを使ってもアイディアがメリットを伝えられるようにする。</li>
<li>シナリオは現実的になって、本当にユーザーが使ってくれるかを結構シビアに考える。ここで楽観的になって間違えるとアイディアが「夢」で終わる。</li>
<li>以前はストーリーフェイズの最初の工程でシナリオを始めていたが、いきなりシナリオを作成するのは難しく、前段階で簡易なジャーニーマップと目次のようなプロットを用意する。</li>
</ul>


<h5>3-3.ジャーニーマップを描く ＊</h5>

<ul>
<li><p>ジャーニーマップには「体系的にタイムライン上のサービス構成をまとめた抽象的なもの」と「シナリオを視覚的に表現した個々の状況にフォーカスしたもの」の2種類があると考える。一般的なジャーニーマップは前者だと思うが、抽象的なジャーニーマップだけでは細かなところの誤解が生まれるかもしれないので、１人のペルソナと１つのメインシナリオをモチーフにした１つの体験を表す。</p>

<ul>
<li>前者

<ul>
<li><img src="http://taninno.github.io/images/post/former.png" width="320"/></li>
<li><a href="http://www.adaptivepath.com/ideas/the-anatomy-of-an-experience-map">http://www.adaptivepath.com/ideas/the-anatomy-of-an-experience-map</a></li>
</ul>
</li>
<li>後者

<ul>
<li><img src="http://taninno.github.io/images/post/latter.png" width="320"/></li>
<li><a href="http://suedesign4.wordpress.com/deliverables/task-3/">http://suedesign4.wordpress.com/deliverables/task-3/</a></li>
</ul>
</li>
</ul>
</li>
<li><p>thatgamecompanyのPS3「風ノ旅ビト」で書いたゲーム全体のユーザー体験の推移を表したものは後者のジャーニーマップに近いかもしれないが、マップという狭義の意味は場合によっては人と異なるのでイメージを確認しておく。</p>

<ul>
<li><img src="http://taninno.github.io/images/post/journey.png" width="420"/></li>
<li><a href="http://www.youtube.com/watch?v=S684RQHzmGA">http://www.youtube.com/watch?v=S684RQHzmGA</a></li>
</ul>
</li>
</ul>


<h5>3-4.ストーリーボードを描く ＊</h5>

<ul>
<li>文章だけのシナリオではイメージが膨らみすぎ、チーム内で認識齟齬が生まれれるかもしれない。そんなときはペルソナを登場人物にしたマンガにする。4コマ漫画のように1つのタスク・シナリオごとに作成する。</li>
</ul>


<h5>3-5.機能要件をまとめる</h5>

<ul>
<li>プロットで記載したサービスやシナリオの途中で気付いたサービスを機能要件として一覧にする。</li>
</ul>


<h4>用語</h4>

<ul>
<li>プロット: 「順番(Step)」「小見出し(Title)」「ユーザーの行動(UserAction)」「ユーザーが思ったこと(UserEmotion)」「必要なサービス内容(Service)」「備考(Memo)」の表を記載していく工程になる。必要であれば「イメージ写真」や「場所」、「タッチポイント」などの列も追記する。この後は小見出しを元にシナリオを記載するが、プロットのボリューム次第ではシナリオはスキップするかもしれない。</li>
</ul>


<h4>備考</h4>

<ul>
<li>プロットやシナリオに対してストーリーボードは形式の違いなのでどちらを使用してもよい。差はそれほど現れないと思う。慣れた方を用いる。</li>
</ul>


<br/>




<div id="section4"></div>


<h3>4.UI</h3>

<p><img src="../../../../../images/approach/04.jpg" />
他のデザインプロセスとの違いとして理解（調査）Phaseに多くの時間を掛けていましたが、もう１つがこのUIPhaseでワイヤフレームを描かないという点があります。アプリやサイトの画面設計においてワイヤーフレームは一般的な設計手法ですが、建築でいうところの図面であり、ストーリーからいきなり図面を描くことはしません。建築物でも必ず模型を作ると思います。模型を作ってみてクライアントのOKが貰えてから図面におこします。<strong>それと同じようにExcelやPowerPointで描いたワイヤーフレーム（図面）を元に開発しても何が出来上がるのかはワイヤーフレームを描いている人しかわかりません</strong>。チームやステークホルダーで共有するには模型（以降、モックアップ）が必要です。そのためワイヤーフレームではなくモックアップをベースにUIを考えていきます。これによって後の進行がスムーズになります。UIの設計プロセスに関しては別途記載していますので、宜しければお読み下さい。 <a href="http://taninno.github.io/blog/2013/09/12/justinmind-prototyper/">Prototyperを使ったモックアップ主導のUI設計プロセス</a></p>

<h4>目的</h4>

<p>シナリオで提示したサービス内容をUIとして図式化する。</p>

<h4>順序</h4>

<ol>
<li>スケッチ</li>
<li>モックアップ</li>
<li>画面詳細設計</li>
<li>絵コンテ*</li>
<li>ガイドライン*</li>
</ol>


<h4>作業</h4>

<h5>4-1.スケッチ</h5>

<ul>
<li>ここのでスケッチは画面アイディアの出発となる荒い状態になる。プロジェクト全員に向けて見せるわけではないので、鉛筆とスケッチブックで落書き以上速記以下の精度で画面を書いていく。

<ul>
<li><img src="http://taninno.github.io/images/post/sketch.jpg" width="320"/></li>
</ul>
</li>
<li>画面と画面遷移は同時に進めていく。画面によって遷移を変更したり、遷移によって画面を変更することがある。</li>
<li>画面レイアウトの考え方の1ではあるが画面設計は演劇と同じように舞台の背景や大道具を決めるのに似ていると思う。同じように画面遷移は場面の切り替えになる。現実の制約に即すというわけれではなく、デジタルならではのインタラクションも効果的だが、舞台演出において観客を悪い意味で驚かすことは望ましくない。垂れてるロープを引っ張ったら上から出てくるべきで、トラップのように下の床が無くなったり、右から矢が出てくるようなことは推奨されない。</li>
<li>画面のインタラクションは画面のメンタルモデルに沿って考える。画面を演劇の舞台のように実際の空間があるように捉えて、役者と舞台装置がワープしないように気をつける。</li>
<li>Leanやアジャイルで進めるならば、スケッチがある程度出来た段階で開発に着手することもあるかもしれない。小中規模開発向けとして生まれたアジャイルや、スタートアップは小規模のLeanにおいては少数精鋭のチームで組織されるならば、1pxの精度で指定されたワイヤーフレームでコミュニケーションする必要はあまりない。</li>
</ul>


<h5>4-2.モックアップ</h5>

<ul>
<li>他の画面と繋がりを常に意識するためにスケッチやワイヤーフレームではなく実際に繋げて遷移を確認する。思い描いたタスクのフローチャートを画面で見てみると思ったのと違う所がでてくる。このような個々の画面の関連は実際のデバイスやマウス・タッチやってみなとわからない。PCのWebならパワポで図形にリンク貼って簡易的でもいいので、なるべく実機で確認する。</li>
<li>操作可能なモックアップを作成したらユーザビリティテストを行う。テスト結果をうけてすぐにモックアップを修正する。そして再度違う人でテストを行い、これを繰り返していく。途中で根本的な設計ミスがあれば<strong>3.ストーリー</strong>に戻る。場合によっては<strong>2.アイディア</strong>の再考が必要になるかもしれない。</li>
<li>インタビュー中に使用するメモ用紙の詳細は<a href="http://taninno.github.io/blog/2014/02/01/usability-testing-template/">ユーザビリティテストのタスクシート</a>を参照。</li>
</ul>


<h5>4-3.画面詳細設計</h5>

<ul>
<li>一般的なワイヤーフレームは画面詳細設計に含めている。ワイヤーフレーム単体でドキュメントとしては成立しない。スケッチはUIを考えるためにあるが、ワイヤーフレームはUIを誰かに伝えるためにあるため、説明や補足、遷移、又は全体の構成を含めた資料として作成する必要がある。</li>
<li>画面詳細設計には全体の画面構成（Webならサイトマップ）からヘッダー・フッターや基本レイアウト画面などの共通項目、そして各画面の詳細画面を記載する。</li>
<li>エラーなどのイレギュラーケースの表現もここから徐々に記載していく。</li>
<li>ここでのワイヤーフレームはスケッチから見えてきた画面のコンポジションやレイアウトを精度を高く記載する段階になる。ワイヤーフレームからはやり直しリスクが高くなるので。例えばビジュアルデザイナーに渡す資料としてワイヤーフレームが土台になるためある分かりやすくに描いておく。可能であれば専用ツールを使用することで効率が良くなるため、なるべく利用する。

<ul>
<li><a href="http://www.justinmind.com/">http://www.justinmind.com/</a></li>
<li><a href="http://proto.io/">http://proto.io/</a></li>
<li><a href="http://uxpin.com/">http://uxpin.com/</a></li>
<li><a href="http://giveabrief.com/">http://giveabrief.com/</a></li>
<li><a href="http://www.infragistics.com/products/indigo-studio">http://www.infragistics.com/products/indigo-studio</a></li>
</ul>
</li>
<li>ただし、ワイヤーフレームは画面設計者とビジュアルデザイナー、デベロッパーが分業してるプロセスに置いては有効だが、画面設計者が画面デザイン、ないし開発も兼ねるのであればワイヤーフレームは必要性が無くなる。ただ１人で全てを行うのは難しいので、理想的なのはUXデザイナーがビジュアルデザインと開発がちょっと出来ることで、ワイヤーフレームを渡すよりも相手のフィールドに合ったファイル形式（デザインであればPhotoshop、開発であればView側のファイルなど）でバトンを渡せるといったことになる。</li>
</ul>


<h5>4-4.絵コンテ ＊</h5>

<ul>
<li>アニメは絵コンテをもとにレイアウトと原画を作るように、アプリケーションやサービスもアニメーションが関係する箇所には絵コンテを用意する。RIAやデスクトップアプリケーション、組み込みでは特にアニメーションによる演出が重要になる。ここでのアニメーションはインタラクションとも呼ばれるユーザーの操作にたいするフィードバックをインタラクションで返すことも含む。</li>
<li>インタラクションはすでにスケッチの段階で考察されている前提になる。ここではチーム間の共有や成果物としての提出の必要がある場合にこのタイミングに設定した。納品物としてだけの意味合いであれば後ろにずらしたほうがいい。</li>
<li>ここでのインタラクションは画面遷移やコンポーネントの詳細、アニメーションを記載した絵コンテのようなものになる。ワイヤーフレームの余白に描くこともあるが、量がある場合は専用のシートを用いて書き起こす。</li>
<li>インタラクションにはユーザーの待ち時間を短く感じさせたり、画面内の情報レベルを表示の順番やパターンで暗に知らせることも負う。画面遷移のトランジションもこれに含まれる。</li>
<li>絵コンテと言ってもプロが作るようなものではなくチラシの裏側で描くレベルで十分にある。</li>
</ul>


<h5>4-5.ガイドライン ＊</h5>

<ul>
<li>ワイヤーフレームを作成している段階である程度の共通項目が現れてくると思う。それを1つにまとめた資料がレイアウトガイドラインになる。量が少なく詳細画面設計に収まれば別添資料にしなくてもいい。</li>
<li>ガイドラインという主にはデザインの指向性を記載したグランドデザインガイドラインやLOOK&amp;FEELのようなボタンやアイコンなどのビジュアルを記載したデザインガイドライン、アプリケーションの挙動や振る舞いの方針をまとめたインタラクションガイドラインなどがある。</li>
<li>ただしルールが多くなると誰も守らなくなってしまう。やる気の問題ではなく、量が多いガイドラインは順守することが不可能になる。ガイドラインは暗記するものではなく、コンセプトやビジョンを汲み取ってもらうことが大切になる。ガイドラインをチェックリストとして扱うと破綻してしまう。</li>
</ul>


<br/>


<h3>4.1.プロトタイプ（option）</h3>

<p><img src="../../../../../images/approach/05.jpg" /></p>

<h4>目的</h4>

<p>具体的なサービス画面まで設計した段階で完成形のイメージの共有を行う。</p>

<h4>備考</h4>

<ul>
<li>ここはラピッドプロトタイプではなくて、ちゃんとしたものを作るイメージ。ラピッドプロトタイプ的なのは既にストーリーやUIのフェイズでモックアップなどのユーザーテストを行なっている前提とする。そのため、既にイメージが見えていればこのフェイズはスキップする。</li>
<li>大型案件であればステークホルダーが多いため、イメージ共有を目的とした実演を実施することを推奨する。</li>
<li>ここでのプロトタイプは技術調査を目的としない。技術調査はアイディアやUIの段階で（大変だが）検証している前提。R&amp;Dのような技術検証が目的である場合を除き、技術的に未検証のアイディアをこの段階まで進めない。アイディアやUIの実現性は技術者と常に確認を行う。</li>
<li>ペーパープロトタイピングではない。ペーパープロトタイピングは実際のデバイス上で確認するよりも精度が下がると考え推奨しない。現在はプロトタイピングツールを利用することにより、ペーパープロトタイピングと同じ時間コストで同等以上のモックアップを作成可能である。</li>
</ul>


<h4>成果物</h4>

<ul>
<li>プロトタイプ</li>
</ul>


<br/>




<div id="section5"></div>


<h3>5.ビジュアルデザイン</h3>

<p><img src="../../../../../images/approach/06.jpg" /></p>

<h4>目的</h4>

<p>ビジュアルイメージを具体的なアピアランスに移行する。</p>

<h4>備考</h4>

<ul>
<li>アイディアを話している時からおそらくビジュアルのイメージはできてるはずで、ここではビジュアルの広報性を議論するのではなく、スキンの開発を行う。</li>
<li>5番である必要はない。</li>
</ul>


<br/>




<div id="section6"></div>


<h3>6.開発</h3>

<p><img src="../../../../../images/approach/07.jpg" /></p>

<h4>目的</h4>

<p>コンセプト(UX)とUIを実現する。</p>

<h4>備考</h4>

<ul>
<li>開発まで1人でやるなら問題ないけど、誰かにお願いするなら遷移の時間感覚やアニメーションのフィーリングを身振り手振りで頑張ってわかるまで伝える。</li>
<li>小規模案件ではプロトタイプを飛ばし、ビジュアルデザインを並行する形で、UI設計段階の途中から開発に着手することもある。</li>
<li>リリース頻度を高くできるようにCI、デプロイ整備を行う。</li>
<li>良いプログラミングを行う。</li>
</ul>


<br/>




<div id="section7"></div>


<h3>7.フィードバック</h3>

<p><img src="../../../../../images/approach/08.jpg" /></p>

<h4>目的</h4>

<p>提供可能になったサービスをフィードバックを得る</p>

<h4>備考</h4>

<ul>
<li>ユーザーリサーチ・ユーザーテスト・ユーザビリティテスト・A/Bテスト・サイト分析・コンバージョン率・SEO</li>
<li>Leanでは親しい顧客に先行して使用もらい、改善案を見つける。</li>
</ul>


<br/>


<h2>補足</h2>

<ul>
<li><strong>2.アイディア</strong>以降はいつでも<strong>1.調査</strong>に戻り、<strong>3.ストーリー</strong>以降はいつでも<strong>2.アイディア</strong>に戻り。（以下同じ）</li>
<li>アイディアやシナリオの時に技術調査や検証をいつでもできるように技術調査フェイズを予め予定しない。6.のプロトタイプは大型案件で全関係者へのお披露目の扱い。</li>
<li>ペルソナはあまり作りこまないで、ユーザーにサービス内容や成果物の出来を聞くようにする。</li>
<li>各工程で疑問や分からないことがあったらノートに書く。その疑問への考えと考えの流れをノートに書く。読み返した時に面白いし、たぶんチーム内の方向性の共有にも使える。WIKIでもbasecampでもyammerにしてもいい。</li>
<li>ユーザーテストの時期は特に規定しない。その時時の期間によって可能な限りのテストを実施する。</li>
<li>プロトタイプとテストのフェイズが独立しているが、試作とフィードバックは常に行う。ただ小回りがきかない受託型のUXでは常に行うのは現実的に難しく、予算の承認のためにも項目としてのこしている。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hart]]></title>
    <link href="http://taninno.github.io/blog/2013/02/18/hart/"/>
    <updated>2013-02-18T01:32:00+09:00</updated>
    <id>http://taninno.github.io/blog/2013/02/18/hart</id>
    <content type="html"><![CDATA[<h2>新しい読書のまとめ方をはじめました</h2>

<p>本を読んでいると、新しい発見に出会うことがあります。そこには知らなかったことや考え方が変わるきっかけ、又はなんとなく思っていたことが言葉になっていることで共感したりします。他にもたくさんの驚きと発見、共感が本にはたくさんあると思います。</p>

<p>Hartはそれらを記していくためのツールです。これまでもたくさんの読書サービスがありましたが、それらはどれも発見を本という単位で捉えるものでした。けれど発見は読み終えた時に生まれるものではなく、読んでいる時に感じるのだと考えます。そこでHartはページ単位のメモを用意しました。読んでいる時に残したい言葉をその場でそのページでHartに書き残していきます。それを１冊の本を読み終えるまで続けるとHartのあなたの本棚にはじぶんにとって大切な言葉が引用集のようにたくさん集まっています。それらを読み返してみると読書ノートのように当時の記憶が蘇ってきます。さらにメモに付随したページ数から簡単にもう一度読み返してみたりするなど、本を読み終えた後の体験がより楽しいものになります。</p>

<p>Hartは個人的な利用のために作ったもので荒削りなところがありますが、自由にご利用できます。もし宜しければ使ってみてください。Hartのコンテンツは自分自身で作っていくため、実際に使っていくことでその楽しさや便利さが感じられるようになります。そしてもしご興味をもっていただけたら一緒に開発して頂ける方をお待ちしております。</p>

<p><a href="http://hart.herokuapp.com/">
<img src="http://taninno.github.com/images/post/hart.png" style="border:solid black 3px" width="480"/></a></p>

<p><a href="http://hart.herokuapp.com/">Hart</a></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generate Rails Command]]></title>
    <link href="http://taninno.github.io/blog/2013/01/17/rails-command/"/>
    <updated>2013-01-17T16:18:00+09:00</updated>
    <id>http://taninno.github.io/blog/2013/01/17/rails-command</id>
    <content type="html"><![CDATA[<h2>Railsのscaffoldコマンド生成ツール</h2>

<p>Scaffoldなどで型の打ち間違えを無くしたいので作りました。</p>

<p><a href="http://sheltered-stream-4127.herokuapp.com/">
<img src="http://taninno.github.com/images/post/001.png" style="border:solid black 3px" width="480"/></a></p>

<p><a href="http://sheltered-stream-4127.herokuapp.com/">Generate Rails Command</a></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jenkinsでgit管理のWindowsPhoneをビルドする]]></title>
    <link href="http://taninno.github.io/blog/2012/08/15/windowsphone-on-jenkins/"/>
    <updated>2012-08-15T22:43:00+09:00</updated>
    <id>http://taninno.github.io/blog/2012/08/15/windowsphone-on-jenkins</id>
    <content type="html"><![CDATA[<ol>
<li><a href="http://jenkins-ci.org/">http://jenkins-ci.org/</a>でWindowsをインストール。</li>
<li>gitやMSBuildなどのプラグインをインストールする。</li>
<li>jenkinsのPath to Git executableには「C:\Program Files\Git\bin\git.exe」を入れる。MSBuildのPath to MSBuildには「C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe」。</li>
<li>個々のジョブを作り設定で、Repository URLにローカルリポジトリだと.gitまでのフォルダパスを入れる。ブランチには今回はmasterを指定している。</li>
<li>ビルドの指定には登録したMSBuildを選択して.slnファイルへの相対パスを指定する。コマンドラインオプションには「/p:Configuration=Release /t:Clean,Build」を入れる。</li>
</ol>


<h2>参考URL</h2>

<ol>
<li><a href="http://tech-old.hilife-jp.info/2011/12/silverlight-unittestjenkins.html">http://tech-old.hilife-jp.info/2011/12/silverlight-unittestjenkins.html</a></li>
<li><a href="http://kiita-it-blog.seesaa.net/article/249556782.html">http://kiita-it-blog.seesaa.net/article/249556782.html</a></li>
<li><a href="http://d.hatena.ne.jp/ch3cooh393/20120126/1327510696">http://d.hatena.ne.jp/ch3cooh393/20120126/1327510696</a></li>
<li><a href="http://blog.gigei.jp/tech/000053.html">http://blog.gigei.jp/tech/000053.html</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[開発環境について]]></title>
    <link href="http://taninno.github.io/blog/2012/08/11/current-environment/"/>
    <updated>2012-08-11T17:11:00+09:00</updated>
    <id>http://taninno.github.io/blog/2012/08/11/current-environment</id>
    <content type="html"><![CDATA[<!-- more -->


<h3>アジャイル</h3>

<p><a href="http://agilemanifesto.org/iso/ja/">http://agilemanifesto.org/iso/ja/</a><br/>
→開発環境ではありませんが以降のツールもスクラムでの開発が想定されていると思います</p>

<h3>Pivotal Tracker</h3>

<p><a href="http://www.pivotaltracker.com/">http://www.pivotaltracker.com/</a><br/>
→スクラム向けスケジュール管理・バグ管理<br/>
　<a href="http://japan.internet.com/wmnews/20120118/7.html">http://japan.internet.com/wmnews/20120118/7.html</a></p>

<h3>Jenkins</h3>

<p><a href="http://jenkins-ci.org/">http://jenkins-ci.org/</a><br/>
→継続的インテグレーション・自動ビルドシステム</p>

<h3>Coverity</h3>

<p><a href="http://www.coverity.com/html_ja/">http://www.coverity.com/html_ja/</a><br/>
→静的ソースコード解析（C#向け）</p>

<h3>Gerrit</h3>

<p><a href="http://developer.aiming-inc.com/ci/jenkins-gerrit-trigger-plugin-usage/">http://developer.aiming-inc.com/ci/jenkins-gerrit-trigger-plugin-usage/</a><br/>
→コードレビュー</p>

<h3>Bugspots</h3>

<p><a href="http://www.publickey1.jp/blog/12/bugspots.html">http://www.publickey1.jp/blog/12/bugspots.html</a><br/>
<a href="http://www.publickey1.jp/blog/11/post_193.html">http://www.publickey1.jp/blog/11/post_193.html</a><br/>
→バグ予測アルゴリズム</p>

<h3>Git</h3>

<p><a href="http://git-scm.com/">http://git-scm.com/</a><br/>
→SVNのようなバージョン管理システム<br/>
　WebサービスとしてはGithubがあります。<br/>
　<a href="https://enterprise.github.com/">https://enterprise.github.com/</a><br/>
　オンプレミスで使用するのであればgitlabがあります。<br/>
　<a href="http://gitlabhq.com/">http://gitlabhq.com/</a></p>

<p> 上記を全て組合せればかなり効率がいい開発が行えると思いますが
まずはちゃんとユニットテストを書かないといけませんよね。<br/>
<a href="http://ja.wikipedia.org/wiki/%E3%83%86%E3%82%B9%E3%83%88%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA">http://ja.wikipedia.org/wiki/%E3%83%86%E3%82%B9%E3%83%88%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA</a></p>

<p>また代替案としてTFSだけで結構実現できることも多いです。<br/>
<a href="http://tfspreview.com/">http://tfspreview.com/</a><br/>
→TFSだとDevOpsの運用に向いていますね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Microsoft Surface 2.0 Design and Interaction Guideline 翻訳]]></title>
    <link href="http://taninno.github.io/blog/2012/08/05/surface-guideline-reading/"/>
    <updated>2012-08-05T13:50:00+09:00</updated>
    <id>http://taninno.github.io/blog/2012/08/05/surface-guideline-reading</id>
    <content type="html"><![CDATA[<p><img src="http://taninno.github.com/images/surface/surface.png"/></p>

<p>Surfaceのデザインガイドラインを自身の理解のメモとして翻訳しています。翻訳の精度は高くありません。Surfaceの名称は「<a href="http://www.microsoft.com/en-us/pixelsense/default.aspx">Pixel Sense</a>」に改名されていますが、ここではガイドラインに従い旧名の「Surface」を使用しています。ガイドラインにはSurfaceの特色であるテーブル型ディスプレイのガイドラインが主な内容ですが、普遍的なインタラクションデザインに関する記載も多くあります。原書には画像付きで分かりやすく書かれているので是非読んでみてください。</p>

<p>Surface 2 Guideline PDF<br/>
<a href="http://www.microsoft.com/en-us/download/details.aspx?id=26713">http://www.microsoft.com/en-us/download/details.aspx?id=26713</a><br/>
Surface 1 Guideline PDF<br/>
<a href="http://www.microsoft.com/en-us/download/details.aspx?id=19410">http://www.microsoft.com/en-us/download/details.aspx?id=19410</a></p>

<br/>


<p>SurfaceSDKのセミナー資料も公開しています。</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/13097810?startSlide=9" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"></p>

<br/>


<p>目次</p>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section1">イントロダクション</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section2">はじめに</a>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section2-1">基本原則</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section2-2">重要事項</a></li>
</ol>
</li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3">デザインプリンシプル</a>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1">インタラクションデザインガイドライン</a>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-1">何人かの人と同じ時間を使った体験を作る</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-2">直接的なタッチインタラクション</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-3">体験を引き立てるために物質的なオブジェクトを使用する</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-4">常にタッチに反応すること</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-5">コンテンツに基づいた体験を作る</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-6">トランジションの注意</a></li>
</ol>
</li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2">ビジュアル＆モーションデザインガイドライン</a>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-1">方向とレイアウト</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-2">深度</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-3">形状</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-4">テクスチャー</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-5">配色</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-6">タイポグラフィー</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-7">イコノグラフィー</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-8">モーションデザイン</a></li>
</ol>
</li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-3">サウンドデザインガイドライン</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-4">言語と文章のデザインガイドライン</a></li>
</ol>
</li>
<li>SURFACE HARDWARE

<ol>
<li>INPUT METHODS</li>
<li>HARDWARE SPECIFIC CONSIDERATIONS</li>
</ol>
</li>
</ol>


<!-- more -->


<h1>Microsoft Surface 2.0 デザイン＆インタラクションガイド &ndash; デザインとアプリケーション開発の原則とガイドライン</h1>

<div id="section1"></div>


<h1>セクション 1.0: イントロダクション</h1>

<p>Sufaceは開発者とデザイナーがユーザーに驚きとソーシャル性とインタラクティブエクスペリエンスを提供することができます。ユーザーは360度全ての側面から互いのコラボレーションによって確かめ合いながら使うことができます。その信頼は堂々巡りの話し合いを止めるのに十分であり、直感的に老若問わずユーザーへ理解させることができます。（タッチやプッシュ、プル、ターン、スクリーンにオブジェクト置くことで？。）Surfaceはユーザーとコンテンツが相互に打ち解け触れ合っていく新しい機会を作ることができます。簡単に言えば、ユーザーが一緒に繋がり、学び、楽しみ、決定する簡単な方法はありません。Surfaceは常に直感的であり、有益であり、魅力的であり、助けになることを約束し、デザイナーと開発者がユーザーが探しだしたり覚えたりする体験を作ります。 説得力のあるSurfaceの体験を作るにはインターフェイスデザインとは異なるアプローチが必要です。このドキュメントはインタラクションとビジュアル、効果音、文章などを含むアプリケーションの主要な側面に関するデザインの原則とインターフェイスデザインのガイドラインを提供します。</p>

<div id="section2"></div>


<h1>セクション 2.0: はじめに</h1>

<p>以降のセクションでは、Surfaceアプリケーションを計画する上で心に留めておくための重要な事柄をハイライトします。</p>

<div id="section2-1"></div>


<h2>セクション 2.1: 基本原則</h2>

<p><strong>楽しさ</strong><br/>
魅惑的な、驚くべき、報われる<br/>
Surfaceは触覚や視覚、聴覚に繋がることでレスポンスと心を捕らえることでユーザーの好奇心に報います。</p>

<p><strong>スマート</strong><br/>
直感的な、精通した、鋭敏な<br/>
Surfaceはユーザーの次の動きを予測します。それは必要な時にタイミング良く明らかにされる重要な情報と上記で誘導します。</p>

<p><strong>控えめな</strong><br/>
優雅な、繊細な、魅力的な<br/>
Surfaceはユーザーがおもてなしと機転を通して体験する中に含まれる可能性を理解することを手助けします。</p>

<div id="section2-2"></div>


<h2>セクション 2.2: 重要事項</h2>

<h3>1. ピクセル対インチ</h3>

<p>Surfaceハードウェアは下記を公開します。</p>

<p>Microsoft.Surface.Input.InteractiveSurfaceDevice.PhysicalScaleTransformproperty.</p>

<p>このプロパティは96dpiとSurfaceのユニットで使用される論理的dpiの間の比率を表します。この変換を使えば、96picelはディスプレイで１つの実際のインチになります。LogicalDpiXとLogicalDpiYのプロパティも公開しています。それらはSurface上で表示された1インチのピクセル数を返します。</p>

<p>それらのプロパティは、UIElementが似たような物理的ディスプレイサイズを持っても、たとえどんなSurfaecデバイスが使われているかに関係なく開発者がアプリケーションを作ることを許可します。このプロパティはスクリーンサイズか解像度に関係なく、適切なサイズのコンテンツを持つアプリケーションを設計する際の手助けとなります。</p>

<p>免責事項：デフォルトの96dpiが想定されるハードウェアのタイプである場合には、全てのディスプレイが実際のピクセルサイズを公開しているわけではありません。</p>

<h3>2. 国際化とローカライズ</h3>

<p>Surfaceアプリケーションは世界中の言語と地域が用意されています。グローバルマーケットで自社のアプリケーションを販売する開発者は国際化が準備されていることを確認してください。アプリケーションインターフェイスは様々なテキスト長や日付形式をサポートするベストプラクティスな設計に従ってください。そして色彩や画像、地政学的な問題の使用にあたっては文化的感性を心がけてください。MSDNオンラインではそれらのベストプラクティスを扱う様々なトピックを持っています。</p>

<p>一般的に、ローカライズされた文字列に対して少なくとも40%のバッファスペースを提供すべきです。</p>

<h3>3. ユーザーの理解</h3>

<p>Surfaceアプリケーション開発より前に、アプリケーション開発者やデザイナーはどんなアプリケーションを開発することが使われることが多いか、そしてビジネスゴールを理解することが大切です。</p>

<div id="section3"></div>


<h1>セクション 3.0: デザインプリンシプル</h1>

<p>デザインはSurfaceのエクスペリエンスの重要な部分です。Surfaceアプリケーションはコンテンツが常に体験の中心であることを保証することを手助けする特別な一連の原則に基づいています。<br/>
顧客の要件と実装はアプリケーションによって異なってきます。そのため開発者がアプリケーションのデザインとスタイルの土台としてのプリンシプルの使用が強く推奨されます。Surfaceのデザインプリンシプルは人々を引き付ける一貫して楽しい体験を作るスタートポイントとして使用すべきです。Surfaceアプリケーションは次の5つのプリンシプルからデザインされています。</p>

<h3>1. Simple (Light and open)</h3>

<p><strong>Surfaceの体験は過度に飾り立てたり装飾しません。</strong><br/>
とてもシンプルで単純なエクスペリエンスの開始アイコンはSurfaceの開始の位置を誘導しています。遊び心のある有機的なアトラクトモード（以下の図の待機画面のこと）とは対照的に、写実的でミニマルな開始アイコンはそれがナビゲーションポイントであることを指し占めています。</p>

<p><img src="http://taninno.github.com/images/surface/001.png" width="240"/></p>

<h3>2. Organized (Hierarchical and structured)</h3>

<p><strong>最も大切な要素は最も視覚が重要です</strong><br/>
Surfaceのランチャーは視覚的にアプリケーションのアイコンやタイトル、説明文にフォーカスできるように整理、構造化されています。このランチャーは繊細で（いくつかの背景に配置した際に？）組織的な本来の意味を持続させます。</p>

<p><img src="http://taninno.github.com/images/surface/002.png" width="240"/></p>

<p>vai:Working with Visual Weight in Your Designs<br/>
<a href="http://sixrevisions.com/graphics-design/visual-weight-designs/">http://sixrevisions.com/graphics-design/visual-weight-designs/</a></p>

<h3>3. 本当のデジタル（いつも通りに誠実に）</h3>

<p><strong>Surfaceは適切な時だけ物理世界をエミュレートし、誠実にデジタルメディアを反映させたデザインスタイルを使用します。</strong><br/>
アトラクト状態は現実世界と水のインタラクションに基づいています。それは通常実現可能な現実世界に装飾されたデジタルな粒子と鮮やかな反射を加え、デジタルメディアに忠実な体験を作り出します。</p>

<p><img src="http://taninno.github.com/images/surface/003.png" width="240"/></p>

<h3>4. コンテンツ指向</h3>

<p><strong>コンテンツはいつも体験の中心にあります。コントロールと装飾は二の次です</strong><br/>
以下の図に示す写真コンテンツはエクスペリエンスの最も大切な部分です。エレメントメニューインジケーター（コンテキストメニューのようなもの）は写真に触れた時にのみ表示します。ユーザーはエレメントメニューのアイコンをタッチした時に選択肢を出すことができます。</p>

<p><img src="http://taninno.github.com/images/surface/004.png" width="240"/></p>

<h3>5.Lively (Soulful and responsive)</h3>

<p><strong>Surfaceは常に反応がよく、アニメーションやモーションはコンテンツをより良くし、コンテンツにスクリーン上で活力をもたらします。</strong><br/>
Surfaceのトランジションは体験を生き生きさせます。ここに示すアプリケーションのローディングトランジション（原書でアプリケーションの起動ローディングを指している）はSurfaceが起動に反応している方法を説明します。アプリケーションアイコンはユーザーの指の下で僅かに拡大し、ランチャーは縮小し、ぼやけ、そしてローディング進行率を示すためにローディングバーがアイコンの下に現れます。</p>

<p><img src="http://taninno.github.com/images/surface/005.png" width="240"/></p>

<div id="section3-1"></div>


<h2>セクション3.1 : インタラクションデザインガイドライン</h2>

<p>インタラクションデザインはユーザーの振る舞いや反応、タッチ、動きを持ったソフトウェア体験の相互作用を定義します。それらのインタラクションガイドラインは直感的で魅力的な均一のSurfaceアプリケーションを作る上で包括的な全体像を含むデザイン原則と関連しています。<br/>
プリンシプルの中にある相互関連性の重要な取り決めがあります。けれど、ガイドラインのどの程度の重要性かは、作成したアプリケーションのタイプによって決まります。</p>

<div id="section3-1-1"></div>


<h3>1. 何人かの人と同じ時間を使った体験を想像する</h3>

<p>Surfaceは50箇所以上のタッチを同時に認識して反応します。それは指やオブジェクトスクリーンをタッチした際にわかります。これは何人かの人々をSurfaceの周りに集めたり、アプリケーションを共有したり、孤独な活動をソーシャルな体験に向上させることを可能にしています。</p>

<h4>a. 360度の水平展開のアプリケーションデザインを使用する</h4>

<p>Surfaceはタッチの方向を認識します。指の方向とオブジェクトがはいちされている位置がスクリーンとの接触によってわかります。開発者が特定の人がスクリーンのどちら側なのかを判断することができます。</p>

<ul>
<li><p>ディスプレイの一方方向だけから向かい合うことを避けて、全員がコンテンツを使えるようにしてください。<br/><img src="http://taninno.github.com/images/surface/006.png" width="240"/></p></li>
<li><p>ユーザーはコンテンツの正面を変えることができます。画面の特定の方向にコンテンツをロックしません。</p></li>
<li><p>Surface2.0 SDKのSacatterViewコントロールを使うことは360度の体験をすぐに可能にします。<br/><img src="http://taninno.github.com/images/surface/007.png" width="140"/></p></li>
<li><p>全ての人がアプリケーションの主要要素に全ての方向から確実に届いて使えるようにします。<br/><img src="http://taninno.github.com/images/surface/008.png" width="240"/></p></li>
<li><p>いくつかの顧客向けアプリケーションではユーザーに対して特別なスクリーンの方向が要求されるかもしれません。これは一般的にアプリケーションのユーザービリティを制限しますので、慎重に検討してください。<br/><img src="http://taninno.github.com/images/surface/009.png" width="240"/></p></li>
<li><p>例えば、共同販売（？）アプリケーションは販売員が常に筐体の近くにいて、顧客は常に反対側にいることが要求されるかもしれません。これは顧客の初期のニーズを満足させるように見えるかもしれませんが、社会的なアピールを制限させるように、アプリケーションを低下させます。</p></li>
<li>インターフェイスはSurfaecの全ての方向から本当にアクセスできます。様々な方向でアプリケーション開発の開始からアプリケーションを使用とテストから始めます。たくさんの人々が同じ時間をテストプロセスを通してアプリケーションを共有することを保証します。</li>
<li><p>もし方向が自由なアプリケーションだったら（天地を持っていなかったら）、ユーザーはアプリケーションの中で天地を変えることができます。<br/><img src="http://taninno.github.com/images/surface/010.png" width="140"/></p></li>
<li><p>Surfaceアプリケーションはユーザーが使用する新しいコンテンツとインターフェイス要素に向かい合わなくてはいけません。開発者は指の方向とコンテンツの方向を使用して、コンテンツと要素をポイントに関する妥当な前提をコントロールします。</p></li>
<li><p>もしアプリケーションがまだ天地の方向を持っていたらユーザーにアプリケーションの方向を変える方法を提供します。<br/><img src="http://taninno.github.com/images/surface/011.png" width="240"/></p></li>
<li><p>簡単なflipボンタはユーザーが誤って触ってしまいやすく、体験が台無しになります。Surfaceランチャーはサイドのハンドルが、グループ化されたコンテンツが回転する前にユーザーに簡単に慎重に実行することを要求します。<br/><img src="http://taninno.github.com/images/surface/012.png" width="240"/></p></li>
</ul>


<h4>b. 垂直に設計された180度のアプリケーションを使用する</h4>

<p><img src="http://taninno.github.com/images/surface/013.png" width="240"/></p>

<ul>
<li>新しいコンテンツとインターフェイス要素をスクリーンの下を向いて、正しい位置に置きます。</li>
<li><p>新しいコンテンツが上下のある物体に見えるようにしてください。<br/><img src="http://taninno.github.com/images/surface/014.png" width="240"/></p></li>
<li><p>人々がどのように水平スペースを使うのかを理解してください。</p>

<ul>
<li>水平設定のスクリーンスペースは何人かの同時に使用するユーザーのためにカラムを区切られます。</li>
</ul>
</li>
</ul>


<h4>c. ユーザーがどのようにスクリーンのスペースを使用するのか理解する</h4>

<p>アプリケーションはひとりのユーザーが見たり、探したり、コンテンツを触ったりすることよりも簡単に多くのユーザーが同時に使える設計にします。</p>

<ul>
<li><p>重要なアプリケーション全体の変更が発生した際に、誰の目にも明らかにします。<br/><img src="http://taninno.github.com/images/surface/015.png" width="240"/></p></li>
<li><p>ユーザーのタッチインタラクションが突然他のユーザーエクスペリエンスに影響しないことを確認してください。</p>

<ul>
<li>例えばペイントアプリケーションで、一人のユーザーが消しゴムコントロールを選択したら、全員のタッチが予期せずにコンテンツを消し始めたとしたら問題です。</li>
</ul>
</li>
<li><p>ユーザーが動かしたりコントロールを使えるようにします。ディスプレイの片側に共有コントロールを接続しないでください。<br/><img src="http://taninno.github.com/images/surface/016.png" width="240"/></p></li>
<li><p>配置によってコンテンツの所有をはっきりさせます。もし新しいコンテンツが特定のユーザーに所属したらスクリーンのユーザーの前に配置してしてください。もしグループ共通コンテンツの部分だったら中央に配置してください。<br/><img src="http://taninno.github.com/images/surface/017.png" width="240"/></p></li>
</ul>


<h4>d. 異なるコラボレーションレベルの違いをサポートします</h4>

<p>3つの異なるコラボレーションのレベルがあります。</p>

<ul>
<li><em>高度に協力的な</em>：ユーザーは同じタスクを互いに助けあいゴールを達成します。</li>
<li><em>やや協力的な</em>：ユーザーはゴールを達成するためにタスクを分けて作業する。これは分割統治法として知られています。<br/>
via:<a href="http://e-words.jp/w/E58886E589B2E7B5B1E6B2BBE6B395.html">http://e-words.jp/w/E58886E589B2E7B5B1E6B2BBE6B395.html</a></li>
<li><em>協力を必要としない</em>：ユーザーは異なるゴールを達成するために別々のタスクに従事します。</li>
</ul>


<p>あなたのアプリケーションでどのようにして異なるコラボレーションを最高のサポートを行うかを理解してください。</p>

<ul>
<li>何人かのユーザーが同時にコンテンツとコントロールを使えるようにしてください。

<ul>
<li>全員が共通コントロールを使うことを要求したとしても進行を止めないでください。</li>
</ul>
</li>
<li><p>機能要素エリア毎にスクリーンを分けないでください。<br/><img src="http://taninno.github.com/images/surface/018.png" width="240"/></p></li>
<li><p>アプリケーションが特別なタスクを実行するために一方の側面を指定し、他の側面には違う機能を指定する時には紛らわしくなります。</p></li>
</ul>


<h4>e. ユーザーがどのようにアプリケーションを実行するのか理解します</h4>

<p>Surfaceは多くのユーザーが同時に使用できるように最適化されていまが、アプリケーションは１人のユーザーにとっても使えるように設計すべきです。特定の人がアプリケーション使えるようにさせ、他の人へ体験を共有するために参加を促すことができます。</p>

<ul>
<li><p>何人かのユーザーが機能的に影響しないことを保証します。</p>

<ul>
<li>１人のユーザーが他のユーザーの参加無しでもエクスペリエンスを楽しみことができるようにします。</li>
<li>新しいユーザーが参加しても、既にアプリケーションを使っているユーザーを中断させないで参加できるようにします。<br/><img src="http://taninno.github.com/images/surface/019.png" width="240"/></li>
<li>１人のユーザーが他のユーザーの体験を中断せずに離脱しても少数の人数が継続できることを確認してください。</li>
</ul>
</li>
<li><p>体験を想像します。それはユーザーが同時にシェアした時の何人かの人と一緒に生き生きとする経験は楽しく、効果的です。</p></li>
<li>適切な場合、ユーザーのタスクを分けたり、ユーザー自身が協業か異なるゴールの達成のためにスクリーンをシェアするかどうかを決めることができるようになるかもしれません。</li>
</ul>


<div id="section3-1-2"></div>


<h3>2. 直接的なタッチインタラクションの使用</h3>

<p>マウスとキーボードのGUIとは対照的に、Surfaceはコンテンツを操作するためにタッチとジェスチャーを使用します。直接的なタッチインタラクションはすぐにユーザーがすぐさま直感的に自身の操作フェードバックを理解することを助け、ユーザーをそれらの体験に通じやすくします。間接的にコンテンツを操作するためにハードウェアかソフトウェアボタンの使用は大概、ユーザーに同じ感覚を与えません。</p>

<h4>a.直接的なタッチインタラクションと間接的なタッチインタラクション</h4>

<p>直接的なタッチインタラクションは指か物理的なオブジェクトによってアプリケーション内の仮想コンテンツの物理的な運動である。直接的なタッチインタラクションは常にアプリケーションのChrome（表層）と抽象的なジェスチャーを信頼しています。例えば、間接的なタッチインタラクションはボタンやスライダー、メニュー、シンボルを描画するジェスチャーを含むことができます。直接的なタッチインタラクションはSurface内での使用ではインタラクションの型を好みます。それはそれらのインタラクションがエクスペリエンス指向のコンテンツをより直感的に想像することを助けるからです。  <p>標準的な直接的なタッチインタラクションを再定義してはいけません。常に正しい結果を生むSurface SDKの処理プロセッサーを使用してください。</p></p>

<ul>    <li>移動：項目の上で１本かそれ以上の指で移動かフリックができること<br/><img src="http://taninno.github.com/images/surface/020.png" width="240"/></li>
    <li>外へのリサイズか拡大：項目の上で２本かそれ以上の指で別々にドラッグする<br/><img src="http://taninno.github.com/images/surface/021.png" width="240"/></li>
    <li>内側へのリサイズか縮小：項目の上で２本かそれ以上の指で一緒にドラッグする<br/><img src="http://taninno.github.com/images/surface/022.png" width="240"/></li>
    <li>１本指での回転：項目を１本指でタッチして、円を回転できるように巡ってぐるりとドラッグする<br/><img src="http://taninno.github.com/images/surface/023.png" width="240"/></li>
    <li>２本指での回転：項目の上で２本以上の指で、相反する方向に弧にそってドラッグする<br/><img src="http://taninno.github.com/images/surface/024.png" width="240"/></li>
    <li>ピンターン：１つの指を残して、もう一つの指を旋回させる。<br/><img src="http://taninno.github.com/images/surface/025.png" width="240"/></li>
</ul>


<ul>
<li>直接的なタッチインタラクションを置き換えるために装飾やコントロールを使用しないでください。

<ul>
<li>例えば、アイテムを回転させるための回転ボタンを使用しないでください。<br/><img src="http://taninno.github.com/images/surface/026.png" width="240"/></li>
</ul>
</li>
</ul>


<h4>b.一本指でドラックやフリックを可能にする</h4>

<ul>
<li>全ての移動可能なコンテンツは一本指でドラックやフリックのインタラクションを可能にしてください。</li>
<li>一貫性のあるドラッグやフリックは、全てのコンテンツが常に基本的なのインタラクション操作ができることをユーザーに明確にさせます。</li>
</ul>


<h4>c.タッチ向けのアプリケーションの設計</h4>

<ul>
<li>インタラクティブな要素は指やオブジェクトにとって適切なサイズでなければいけません。

<ul>
<li>幾つかのアイテムはユーザーのタッチに反応します。タッチの対象となるものは少なくとも18mmの縦横のサイズであるべきです。<br/><img src="http://taninno.github.com/images/surface/027.png" width="140"/></li>
<li>タッチ対象の間は少なくとも3mmの間を持たせます。<br/><img src="http://taninno.github.com/images/surface/028.png" width="140"/></li>
<li>インタラクションな要素は手や腕やオブジェクトがスクリーンを覆ってインタラクション要素を持つ関連のあるコンテンツを妨げないように配置します。<br/><img src="http://taninno.github.com/images/surface/029.png" width="240"/></li>
</ul>
</li>
</ul>


<h4>d.マルチタッチへの応答</h4>

<ul>
<li>Surfaceは同時に50箇所以上のタッチを認識して反応します。</li>
<li>アプリケーションはマルチタッチに反応しなければなりません。</li>
<li>ユーザーはあらゆる体験においてマルチタッチのインタラクションが使用出来ると予期します。それはアプリケーションの自身の場所だけとは限りません。</li>
</ul>


<div id="section3-1-3"></div>


<h3>3. 体験を引き立てるために物質的なオブジェクトを使用する</h3>

<p>連続して途切れないサーフェイスの体験がフィジカルとバーチャルな世界を融合させることによって、ユーザーは没入することになります。</p>

<h4>a. タグオブジェクトの使用</h4>

<p>Surfaceの主要な差別化要因として、物体の認識機能があります。オブジェクトはユーザーがアプリケーションの体験に繋がることを手助けします。この方法は昔ながらのUIでは不可能です。
システムが素早く正確に認識することを助けることができる特別なオブジェクトを配置します。タグは赤外線を吸収したりエリアを取り込む幾何学的な配列から成り立つユニークなパターンです。タグオブジェクトがスクリーンに置かれた時、ビジョンシステムはタグを読み取り、値や位置、方向を決定します。</p>

<ul>
<li>共有や自身のスペースを向上させるためのオブジェクトの使用

<ul>
<li>例えば、教育アプリケーションはオブジェクトを各生徒のレッスンの進捗を割り当てるためにオブジェクトを使用するでしょう。</li>
</ul>
</li>
<li>はしゃいだり愉快な体験のためのオブジェクトの使用

<ul>
<li>例えば、ゲームの駒は異なる駒に様々なアニメーションを与えます。プレイヤーがスクリーン上に駒を配置した時、タグがプレイを促すアニメーションを引き起こします。</li>
</ul>
</li>
<li>ユーザーと他のユーザーとのフィジカルな設定を作るためにオブジェクトを使用する。</li>
</ul>


<p>タグ付けされたオブジェクを利用するアプリケーションがすべきこと</p>

<ul>
<li>タグオブジェクトにすぐさま反応する。</li>
<li>この即座の反応はユーザーにデバイスが動いていることを知らせます。</li>
<li>視覚的な反応を作ることはオブジェクトに適しています。</li>
<li>バーチャルな効果を伴った明確な物質的なオブジェクトとの繋がり（？）<br/><img src="http://taninno.github.com/images/surface/030.png" width="240"/></li>
<li>体験を強化して裕福にするオブジェクトの使用は、タグオブジェクトの存在を必須にしてはいけません。</li>
<li>赤外線を反射しないオブジェクトの使用はアプリケーションとの接続ができません。<br/><img src="http://taninno.github.com/images/surface/031.png" width="240"/></li>
<li>もしオブジェクトの赤外線反射が要求される場合、これらの連絡先をフィルタリングするために、オブジェクトの位置や形の知識を使用します。</li>
</ul>


<h4>b. 非タグオブジェクトの使用</h4>

<p>非タグオブジェクトはブログ（Blob）として参照されます。Surfaceはスクリーンに置かれた赤外線（IR）を反射するオブジェクトを見つけることができます。非タグオブジェクトからのコンタクトは、例えば全ての手がスクリーンに置かれた場合にブロブとして登録された他のオブジェクトからのコンタクトと同じになります。</p>

<p><img src="http://taninno.github.com/images/surface/032.png" width="240"/></p>

<p>アプリケーションは非タグオブジェクトを以下のように利用すべきです。</p>

<ul>
<li>非タグオブジェクトの存在に直ぐ反応してください。この機敏な反応でユーザーにデバイスが動作していることを知らせられます。</li>
<li>スクリーンにオブジェクトが置かれたら常に視覚的なサインで認識していることを表示してください。たとえそれが特別なものでなくとも。</li>
<li>ブロブプロパティからオブジェクトの形やサイズを特定できるとことを期待しないでください。全てのオブジェクトの形は楕円形で、サイズは赤外線が反射したオブジェクトの一部を示しています。</li>
</ul>


<h4>c. 物質的なオブジェクトであるかのようにみせる</h4>

<p>スクリーンではオブジェクトは移動中の微かな物理特性や運動の慣性、自然な感じの衝突で、矛盾の無い感覚を作ることを助けるべきである。</p>

<ul>
<li>現実の操作から始まるインタラクティブなメタファーを利用してください。そして、現実世界で可能なことを超えて、デジタルで起こりえることを囲い込んでください。

<ul>
<li>例えば、フォトアプリケーションでフリックで写真を移動させることができるでしょう（現実の動きを模倣して）。そして、ユーザーは簡単な操作で写真を拡大することもできます。（この場合は仮想空間だけで可能ですが）<br/><img src="http://taninno.github.com/images/surface/033.png" width="240"/></li>
</ul>
</li>
<li>mass(?)や加速、摩擦、粘性、重力を利用して状態推移の現実世界を模倣してください。

<ul>
<li>例えば、SDKにある<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.controls.scatterview.aspx">ScatterView</a>コントロールは簡単にそれらの効果を可能にします。</li>
</ul>
</li>
<li>オブジェクトとコンテンツの慣性を使用してください。</li>
</ul>


<p>これらは各アプリケーションの体験を通して矛盾の無い体験を作るのに貢献します。<a href="http://msdn.microsoft.com/en-us/library/ff727815.aspx">Surface SDK</a>の慣性処理は慣性を実行しやすくします。</p>

<div id="section3-1-4"></div>


<h3>4. 常にタッチに反応すること</h3>

<p>ユーザーは動かない何かを試すことがあり（？）、それを受けて、視覚的なフィードバックがそれらを学習し、問題解決かポジティブな方向へ促すことを助けるべきです。</p>

<h4>a. ユーザーを視覚的なヒントと間に合わせのクロムで誘導させる</h4>

<ul>
<li>ユーザーにインタラクションがすべきことについての視覚的なヒントを提供する。   + 例えば、ランチャーの回転ハンドルは、視覚的なヒントを使用しています。それはコントロールを回転させるためのタッチインタラクションであることです。<br/><img src="http://taninno.github.com/images/surface/034.png" width="140"/></li>
<li><p>インタラクションを誘導するために、間に合わせのクロムを使用します。間に合せのクロムはコントロールが必要なときだけ公開されることを意味します。</p>

<ul>
<li>例えば、フォトアプリケーションで、ElementMenuがスクリーンに常にいるよりは、個々の写真をタッチして現れるべきです。<br/><img src="http://taninno.github.com/images/surface/035.png" width="140"/></li>
</ul>
</li>
</ul>


<h4>b. 即時の喜びと達成感を確保する</h4>

<ul>
<li><strong>視覚的にタッチを認識する</strong>
タッチの視覚化は素早く正確にアプリケーションがタッチを視覚的に認識することを見越しておく。<br/><img src="http://taninno.github.com/images/surface/036.png" width="140"/>

<ul>
<li>すべてのコンテンツはタッチに反応し、即時視覚化しなければならない。</li>
<li>タッチは深さや、白熱光か他の可視化を認識することができる。</li>
</ul>
</li>
<li>アプリケーションは即時にタッチポイントに即時に反応しなければならない。</li>
<li>ユーザーに体験を制御させ、過度のオート操作を提供してはいけない。</li>
</ul>


<h4>c. 魅力のある知覚的フィードバックを提供する</h4>

<p>ビジュアルやサウンド、モーション、フィジカルインタラクションを通して、ユーザーが感知する魅力的なフィードバックを提供する</p>

<ul>
<li>シナリオに適して、楽しませるビジュアルを盛り込む。</li>
<li>ユーザーが何か起こったのかを理解するのを、助けるアプリケーションに適したサウンドを盛り込む。</li>
<li>ビジュアルが合図を送り、ユーザーをアプリケーションの新しい環境やポイント、効果を導くヒントを伝える。

<ul>
<li>例えば、アプリケーションはアニメーションを使って、インタラクションを教え、機能を導くヒントを伝えることができる。</li>
</ul>
</li>
</ul>


<h4>d. 視覚的なヒントとタッチインタラクションを教えるためのガイダンスアニメーションを使用する</h4>

<ul>
<li><p>目に見えないコンテンツに対して視覚的なヒントを提供する。直感的に、非階層アプローチの探索はSurfaceの体験の基本です。そして、時々ユーザーがそれらをガイドする手がかりとヒントを要求します。<br/><img src="http://taninno.github.com/images/surface/037.png" width="140"/></p>

<ul>
<li>例えば、ランチャーアニメーションはアプリケーションのアイコンがスクロール・インするのを表示します。そして、アイコンがランチャーがスクロール可能だということ、追加のコンテンツがあることを示すために縮みます。</li>
</ul>
</li>
<li><p>ユーザーの謝った行為を防ぐために、視覚的なヒントを提供します。</p>

<ul>
<li>例えば、ユーザーが取り出せないディスプレイの範囲外のコンテンツを外側に移動することを許可しません。<br/><img src="http://taninno.github.com/images/surface/038.png" width="140"/></li>
</ul>
</li>
<li><p>機能を明らかにするためにガイダンスアニメーションを使用します。</p>

<ul>
<li>例えば、音楽を探すアプリケーションで、アルバムのジャケットがScatterViewItem
です。ユーザーがそれらをタッチすることができ、フリックするとアルバムのコンテンツが明らかになります。アプリケーションが起動した時、ジャケットは特定の場所にアニメーションし、幾つかのアルバムは追加コンテンツがあることをデモンストレーションのためにひっくり返ります。</li>
</ul>
</li>
</ul>


<div id="section3-1-5"></div>


<h3>5. コンテンツに基づいた体験を作る</h3>

<p>コンテンツ指向のアプリケーションは探索と発見を促します。コンテンツにフォーカスされた体験はユーザーが使う上でより直感的に楽しくあります。</p>

<h4>a. コンテンツをインターフェイスとする</h4>

<ul>
<li>ダイレクトタッチインタラクションを、ボタンやメニューやスライダーのようなUIコントロールに置き換えないでください。</li>
<li>スクリーンを不必要で余分なUIコントロールとクロムで散らかさないでください。</li>
<li>プライマリインタラクションとしてタッチを取って代わらないでください。

<ul>
<li>プライマリインタラクション（タッチ）を置き換えると行った方法で、外部の入力デバイスをSurfaceと接続しないでください。</li>
</ul>
</li>
<li>アプリケーションはそれを置き換えることなく、Surfaceのタッチエクスペリエンスをサポート、推奨しなければなりません。</li>
</ul>


<h4>b. インタラクティブな要素は特定しやすいようにする</h4>

<ul>
<li>視覚的なタッチコンテンツのサインは、ユーザーがインタラクティブでない何かをタッチすることを誤らないように正確であるようにしてください。

<ul>
<li>例えば、非活性ボタンは必ず視覚的な活性ボタンとは異なるようにしてください。<br/><img src="http://taninno.github.com/images/surface/039.png" width="240"/></li>
</ul>
</li>
<li>大きなインターフェイスの要素だと、より速くユーザーがインタラクティブを特定できるようにしてください。<br/><img src="http://taninno.github.com/images/surface/040.png" width="240"/></li>
<li>オブジェクトがインタラクティブかどうかを示すのを助けるような、深度（重なり）を使用してください。<br/><img src="http://taninno.github.com/images/surface/041.png" width="140"/></li>
</ul>


<h4>c. エクスペリエンスに重点を置く</h4>

<ul>
<li>アプリケーションのいくつかの機能を減らしてください。個々のアプリケーションのシナリオをユーザーが使える必要性に対応する（？）。</li>
<li>個々の機能とユーザーに明らかなそれらのタスクに、焦点をあてた機能のセットに重点をおいてください。</li>
<li>ユーザーが決めるのに時間がかかったり複雑さを減らすために、似たような選択肢は制限してください。

<ul>
<li>複製されたコントロールといくつかの機能を提供するインターフェイスは混乱させます。</li>
<li>たくさんの選択肢が必要となった時は、<a href="http://msdn.microsoft.com/en-us/library/ff727728.aspx">ElementMenu</a>を使用してください。<br/><img src="http://taninno.github.com/images/surface/elementmenu.png" width="140"/>

<ul>
<li>シンプルで組織化された階層的な構造</li>
<li>ユーザーはタップとスライドでメニューを通してナビゲートすることができます。</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>d. 行動と学習を統合する</h4>

<ul>
<li>もし使用上の注意が必要であれば、それらとアプリケーションの流れを統合して、コンテンツから注意を外さないようにしてください。</li>
<li>主要機能はすぐに見つかるようにしてください。</li>
</ul>


<div id="section3-1-6"></div>


<h3>6. トランジションの注意</h3>

<h4>a.トランジションは滑らかで流れるようでなければいけません</h4>

<p>滑らかなトランジションはユーザーにそれがあることの文脈（背景）を知らせます。<br/><img src="http://taninno.github.com/images/surface/042.png" width="240"/></p>

<ul>
<li>滑らかな各トランジションはユーザーに連続したフローをし続けます。</li>
<li>不快なトランジションは避ける。

<ul>
<li>滑らかなトランジションは、ユーザーを適用させ続けることを助けます。</li>
</ul>
</li>
<li>突然現れたり、消えたりすることはありません。</li>
<li>各オブジェクトと視覚的な要素の変更は、滑らかに活動させ以降して、無くなるか途中で変わるかします。<br/><img src="http://taninno.github.com/images/surface/043.png" width="240"/></li>
</ul>


<h4>b.意図的ではないものか有害な主要トランジションかを避ける</h4>

<ul>
<li>ユーザーにより、破壊と明確に意図した作動された大きな変更を要求する。

<ul>
<li>例えば、アクセスポイントは、アプリケーションを離脱するか始めるための明確な入力を要求します。この２ステップの方法は想いもしない予期しない起動を引き起こします。<br/><img src="http://taninno.github.com/images/surface/044.png" width="240"/></li>
</ul>
</li>
<li>フレンドリーで歓迎するアプリケーションの環境を作成します。それはユーザーが簡単に探したり、実験するために招待します。</li>
</ul>


<div id="section3-2"></div>


<h2>セクション 3.2: ビジュアル＆モーションデザインガイドライン</h2>

<p>このセクションでは、ビジュアルデザインとモーションデザインに関する個々のデザインガイドラインを提供します。</p>

<div id="section3-2-1"></div>


<h3>1. 方向とレイアウト</h3>

<p>Surfaceでのビジュアル要素のレイアウトは、興味深い機会に360度のマルチユーザーインターフェイスを提供します。ほとんどのアプリケーションでは、ほとんどの人はディスプレイのどの側からでも、読んだり、理解したり、スクリーンのオブジェクトと相互にやり取りしたりできるべきです、いつでも。Surfaceにしばし「絶対的な方向」はありません。それどころか明確な上、下、左または右はありません。各ユーザーの相対的な位置の観点で考えることがベストです。どこにオプジェクがいても回転されたり、配置されたり、デバイスを使っているユーザーから離れたりするかもしれません</p>

<h4>a. アプリケーションの方向</h4>

<p>アプリケーションが起動された時、デフォルトの方向が最もデバイスの周囲にいるユーザーにとってメリットがあることを確実にします。</p>

<p><em>水平での展開</em></p>

<ul>
<li>もしアプリケーションが自由な方向のコンテンツを持つことができたら、コンテンツが回転でき、動かせることをユーザーに示すべきです。</li>
<li>もしアプリケーションが特定の方向に向かなければならないのであれば、ランチャーと同じ方向に従うべきです。</li>
</ul>


<p><em>垂直での展開</em></p>

<ul>
<li>アプリケーションはスクリーンの下に向かってのみ正しい方向に置くことができます。そして、アプリケーションは（水平と同じように）ランチャーと同じ方向に従うべきです。</li>
</ul>


<h3>b.フリーグリッドレイアウト</h3>

<p>多くのビジュアルデザイナーはグリッドをベースにしたレイアウト作成を学んできました。360度のSurfaceの性質は、グローバル（？）、ワイドスクリーン、グリッドシステムを用いないレイアウトにとって良いものです。これにはビジュアルレイアウトの新しい考え方を必要とします。Surface SDKの<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.controls.scatterview.aspx">ScatterView</a>コントロールは、すぐに簡単な方法でグリッドフリーグローバルレイアウトを作成できます。それはユーザーに準備させ、コンテンツを探索することを勇気づけます。ScatterViewは目に見えないオブジェクトのコンテナーを演じます。いくつかのコンテンツは、デフォルトでスクリーンの端に向かって正しい方向に向くことになります。好奇心として、ダイレクトタッチインタラクションとして、探索としても演じます。<br/><img src="http://taninno.github.com/images/surface/045.png" width="240"/></p>

<p>ただ、レイアウトは常にグリッドフリーを必要としません。例えば、<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.controls.librarycontainer.aspx">LibraryContainer</a>コントロールは、すぐにグリッドフリーレイアウトのセクションの順番で作成します。そして、コンテンツは簡単にソートされ、フィルター、体系化されるでしょう。アプリケーションはユーザーに決めさせることができます。異なる視覚的な組織化の方法を、いつ切り替えるかどうかを。（LibraryContainerは以下の図のようにコンテンツを束にしたり、一覧のように並べかえることができます。）<br/><img src="http://taninno.github.com/images/surface/046.png" width="240"/></p>

<h3>c.格子レイアウト</h3>

<p>グリッドをベースにしたレイアウトは、まだ立場を持っており、現在のSurfaceアプリケーションに役立つことができます。格子状のレイアウトは、生産性やアクティビティ、データのソーティングに適しており、簡単に視覚的なリズムを生み出すことができます。Surfaceの体験に向けたレイアウトグリッドはローカル（特有な個々のコンテンツアイテム）にも、グローバル（ワイドスクリーン）にも可能です。</p>

<ul>
<li><p><strong>ローカルグリッド</strong>
特別なオブジェクトに適用するレイアウトシステムがあります。画面の全体にではなくです。特に役立つローカルグリッドの実装は<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.controls.scatterviewitem.aspx">ScatterViewItem</a>の内部で行われます。ScatterViewを用いて360度のアプリケーションを作ることが可能になります。しかし、ローカルグリッドは体系化と構造を与えるScatterViewの内部で利用できます。<br/><img src="http://taninno.github.com/images/surface/047.png" width="240"/></p></li>
<li><p><strong>グローバルグリッド</strong>
グローバルグリッドはコンテンツとアプリケーション全体のコントロールの範囲を決定します。ワイドスクリーンのグローバルグリッドは、複製されたコントロールが各ユーザーに用意された時、又はスクリーンの両側に配置された時に役立ちます。簡単に調査し、体系化することを可能にしている間に、しばし、スクリーンの一方方向に向かってUI全体を押し進めます。それが、ユーザーの共同を難しくさせます。もしグローバルグリッドで要素をレイアウトしているとしたら、各ユーザー、各側へのコンテンツの方向の考察を気にかけてください。<br/><img src="http://taninno.github.com/images/surface/048.png" width="240"/></p></li>
</ul>


<div id="section3-2-2"></div>


<h3>2. 深度</h3>

<p>Z軸か深度を使用して、コンテンツの編成と視覚的な優先順位付けがよりパワフルになります。深度は要素の表面を背景から分離することを助けます。そして、操作可能なものとそうでないものを明確に分離することも助けます。Surfaceアプリケーションは深度をあらゆる場所の体験と様々な状態のアトラクト（水の波紋がある画面のことです）、ランチャーそしてアプリケーションのトランジションに使用します。<br/><img src="http://taninno.github.com/images/surface/049.png" width="240"/></p>

<ul>
<li>深度を優先度、順番、コンテンツアイテム間の集中を表すために使用します。</li>
<li>浅く、かすかで、上品な深度の見え方を維持してください。</li>
<li>オブジェクトとコンテンツにうまくタッチできると認識するために深度を使用してください。タッチに成功した指に向かって浮いてるコンテンツのような錯覚を与えてください。それらのタッチされたアクティブなオブジェクトは最も高い深度を確保してください。</li>
<li>コンテンツとタッチ可能な領域を視覚的に示したコントロール内部で深度を使用してください。</li>
</ul>


<h3>a. 2.5次元の深度の作成</h3>

<p>2.5次元はシミュレーターや、本当の3次元ジオメトリックスを使わない深度で錯覚させる技術に代表されます。いくつかの技術は特別なXAMLを用いた3次元ツールとハイパフォーマンスなWPFを無しで実現されます。</p>

<h4>i. 拡縮</h4>

<p>拡縮は深度をシミュレーションすることができます、特に他の技術と結合して。拡縮はタッチ入力の成功を登録させるために望ましい方法です。それは、少し拡大を増加させ（または錯覚のために）、オブジェクトが指に帯磁する印象を与えます。異なるレベルの深度で拡縮が大きな違うと、深い背景の見かけに繋がることがあります。ユーザーに没頭した体験を維持するため、小さな微かな拡大の変化を使います。<br/><img src="http://taninno.github.com/images/surface/050.png" width="240"/></p>

<h4>ii. ドロップシャドー</h4>

<p>かすかなドロップシャドーは簡単に深度を示すのに効果的な方法です。しかし、重すぎにすることは重要ではありません。ダークシャドーはコンテンツの下を目立たなくさせることができます。そして、とても大きな補正値は、ディスプレイからオブジェクトが繋がってないのではと感じさせることができます。<br/><img src="http://taninno.github.com/images/surface/051.png" width="240"/></p>

<h4>iii. 透過</h4>

<p>透過は、上のオブジェクトを通して低いレベルのオブジェクトを表示するに深度を利用することができます。この技術は少ない数のオブジェクトに対しては有効です。その一方で、透過にはレンダリングするための計算が高くなることがあります。<br/><img src="http://taninno.github.com/images/surface/052.png" width="240"/></p>

<h4>iv. 遠近感を与える</h4>

<p>奥行きの付与は、着色、彩度の縮小、両方またはいずれか一方の離れたオブジェクトをシミュレーションするためにコントラストの低下を使用します。深度を伝達するための明るさのかすかな低下は、すぐに効果を出すことができます。<br/><img src="http://taninno.github.com/images/surface/053.png" width="140"/></p>

<h3>b. 3次元の深度の作成</h3>

<p>本当の3Dは現実の3次元ジオメトリックのレンダリングを使用します。このため、現実的なキューブの回転やシェイプ、カスタム3Dモデリングなどなどを有効（可能）にします。3DはXAMLやWPFを利用して生み出すことができるとはいえ、それは逆にアプリケーションのパフォーマンスに影響を与えることになります。本当の3DはXNAを使用したSurfaceで作成、配信されるのがベストです。それはMicrosoftの3Dのコアでゲームエンジンです。<br/><img src="http://taninno.github.com/images/surface/054.png" width="180"/></p>

<p>真の3Dはインターフェイスの革新の多くの機会を与えます。しかし、3Dコンテンツをデザインする時には注意が必要です。2次元のタッチSurfaceで3Dのオブジェクトをコントロールすることは難しく混乱させることがあります。3Dは以下を常に避けるべきです。幾つかのテキストやラベルが3Dの表面上に配置され、読むことが難しくなるコンテンツの作成を。<br/><img src="http://taninno.github.com/images/surface/055.png" width="340"/></p>

<p>3Dの深度を使用してスクリーン上のオブジェクトを説明はできないと考えます。しかし、それよりむしろバーチャル空間はでアプリケーションの中でユーザーを導きます。</p>

<h3>c. 視覚的な手がかりとしての深度</h3>

<p>深度はタッチ入力が操作可能な領域を示すことにも使用することができます。これはユーザーが、他のタッチしたことよりも異なる結果になることを理解することを助けます。例えば、ヘッダーかコンテンツのタイトルバーはドラッグできるように見えます。しかしオブジェクトの中のリストアイテムはドラッグした時にスクロールします。コントロールの一部分を、それらの領域をユーザーが特定することを助けることができる他の要素の上か下かに表示します。それらの目的を簡単に理解させます。（？）<br/><img src="http://taninno.github.com/images/surface/056.png" width="340"/></p>

<div id="section3-2-3"></div>


<h3>3. 形状</h3>

<p>Surfaceのコンテンツの形状は機能を視覚的に示さなければなりません。</p>

<h4>a. 境界と端</h4>

<p>アプリケーションのエッジとコーナーのスタイルは、ユーザーの趣味に合うのエクスペリエンスの感情を与えます。</p>

<ul>
<li>Style 1: <strong>平面</strong></li>
</ul>


<p>Surfaceのアクセスポイントとランチャーは簡潔、フラット、シンプルでデジタルであることが重要です。この様式はアクセスポイントとランチャーが、Surfaceの体験をナビできる操作可能な要素として示します。それらのナビゲーションコントロールはコンテンツの次（補助的な）です。それらナビは注意をそららさず、ユーザーが次の体験を得ることを助けます。<br/><img src="http://taninno.github.com/images/surface/057.png" width="380"/></p>

<ul>
<li>Style 2: <strong>自然</strong></li>
</ul>


<p>アトラクト状態は容積、自然な形状に基づいています。それらは試しのタッチを勧めます。丸みを帯びた自然な形状は一般的に親しみやすさや見つけやすさ、没入感に優れています。<br/><img src="http://taninno.github.com/images/surface/058.png" width="380"/></p>

<p>それら（平面と自然）の様式のバランスはアプリケーションに適した体験を得ることを助けます。</p>

<h4>b. 罫線と輪郭</h4>

<p>Surfaceのインターフェイスは、一般的に自由なアウトラインで、コンテンツのフォーカスを維持します。もしインターフェイス要素がアウトラインを要求したら、最小2pxの罫線を維持してください。回転や拡縮した時にベストな結果を生み出します。<br/><img src="http://taninno.github.com/images/surface/059.png" width="180"/></p>

<div id="section3-2-4"></div>


<h3>4. テクスチャー</h3>

<p>一般的に、奇麗に装飾されたテクスチャーの使用はSurfaceの体験では推奨されません。装飾的なテクスチャーはコンテンツを損なう傾向があります。コンテンツは常にエクスペリエンスのコアであるべきです。概して単に美学の理由で利用されるテクスチャーが作る体験は本当のデジタルではありません。</p>

<p>テクスチャー自体がコンテンツであるアプリケーションもいくつかはあるかもしれません。もしテクスチャーがアプリケーションで使用しなくてはいけないとしたら、ミニマムで一貫性を維持し、常にタッチと探索を推奨することにフォーカスさせます。</p>

<p>テスクチャーが視覚的なヒントとしてユーザーへアプリケーションの使用を助けるために演じている間は、他の多くのビジュアルデザインテクニックが同じゴールを達成ことができます。それは、ナビゲーションスペース、シェイプ、フォーム、形状、配色などなど。視覚的なヒントとしてのテクスチャーの使用に変わるものを探索してください。</p>

<div id="section3-2-5"></div>


<h3>5. 配色</h3>

<p>デザイナーは実証された配色デザインのガイドラインに従わなくてはいけません。そして、彼らがハンドリングしている特定のブランドの要求を考慮しなくてはいけません。それにはいくつかの追加のガイドラインがあります。Surfaceのディスプレイに色彩再現を最適化させることです。</p>

<h4>a. 配色の利用</h4>

<ul>
<li><p>デザインプロセスの中で全ての配色を試験します。反復の試験は一貫性や明るさやSurfaceのスクリーンで最適化された配色を獲得するベストな方法です。試験のためにデスクトップモニターに頼らないでください。</p></li>
<li><p>背景色に真っ白な色は使わないでください。</p></li>
<li><p>まぶしさや飽和したトーン（色調）は狭い範囲で目の疲労を減少させることの最良の方法です。</p></li>
<li><p>ハイコントラストや真っ黒や真っ白はアンチエイリアス（表面要素の端が背景の上でかすかに混ざり合う）の有効性を減少します。文字が見えづらいようにさせ、回転したときにオブジェクトとコンテンツの端にギザギザの段々の効果を発行させます。</p></li>
<li><p>全てのアクションに対してステージを背景のように扱います。それは繊細で快適でありながら地味であるべきです。</p></li>
<li><p>慎重に、繊細な傾斜をつけます。コントラストを減らした配色は繊細な傾斜は１つの統一されたトーンとして平坦にし、表示されるようになるはずです。</p></li>
<li><p>バンディング（プリンタで印刷するときにトナーが少ないなどの理由で濃淡の縞が発生すること）の確認のためにもSurfaceのディスプレイで色調の傾斜をテストしてください。</p></li>
<li><p>実験や反復そして探索はSurfaceのディスプレイの特性を良く理解することになります。先入観を持たずに、確立された配色パターンに対して、新たなアプローチをとってください。</p></li>
</ul>


<h4>b. Surfaceカラー</h4>

<p>管理者はSurfaceのカラースキームのデフォルトを制御します。国際的なカラースキームはアプリケーションでレンダリングされるSurfaceコントロールのデフォルトカラーを決定します。アプリケーションの追加要素のスタイルにも同じ配色を使用することができます。また一方で、それらを使ったアプリケーションのいくつかの要素に影響を及ぼすSurfaceカラーを上書きすることができます。</p>

<p>Surfaceには既に定義された4つの配色パターンがあり、<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.palettes.aspx">Microsoft.Surface.Presentation.Palettes</a>名前空間で定義されています。</p>

<ul>
<li>Light palette</li>
<li>Dark palette</li>
<li>LightHighContrast palette</li>
<li>DarkHighContrast palette</li>
</ul>


<div id="section3-2-6"></div>


<h3>6. タイポグラフィー</h3>

<p>Surfaceアプリケーションのタイポグラフィーは意味のある優雅でなくてはいけません。Surfaceの体験の中心にあるシンプルなインターフェイス要素とコンテンツを伴って、スクリーン上のテキストそれ自体がインターフェイスとしてさらに振る舞う機会を持ちます。</p>

<h4>a. Segoe360</h4>

<p>Segoe360はSurface用に特別に設計された書体です。Segoe360をアプリケーション内で使用を強く推奨される理由は以下の通りです。</p>

<ul>
<li><p>Segoe360は3つの大きさ（レギュラー、イタリック、ボールド）があります。<br/><img src="http://taninno.github.com/images/surface/060.png" width="180"/></p></li>
<li><p>Segoe360のレギュラーは、Segoe UIとSegoe UI Semiboldの間の新しい大きさであり、Surfaceでより存在感を持つように設計されています。<br/><img src="http://taninno.github.com/images/surface/061.png" width="180"/></p></li>
<li><p>文字はどのアングルから見ても区別しやすいように変更され、どの方向からも読みやすくなりました。例えば、小文字のl（エル）は大文字のI（アイ）よりもより区別しやすくなり、小文字のq（キュー）は小文字のb（ビー）が回転した時よりも区別しやすくなっています。<br/><img src="http://taninno.github.com/images/surface/062.png" width="180"/></p></li>
<li><p>トラッキング（全体の文字間隔）はより読みやすくするために増加し、スクリーンに最適化されました。特に小さな文字に対して。</p></li>
<li><p>カウンター（aやeのような文字の閉じているエリア）は小さいサイズでも可視性が保たれるように広くしました。</p></li>
<li><p>Segoe360は西ヨーロッパや東ヨーロッパ、トルコ、バルト、ギリシャ、キリルの文字セットをサポートしています。</p></li>
</ul>


<p>Segoe360の最小サイズ</p>

<ul>
<li>インターフェイス要素のラベルには12pt</li>
<li>本文や文章には16pt<br/><img src="http://taninno.github.com/images/surface/063.png" width="280"/></li>
</ul>


<h4>b. 書体の選択</h4>

<p>SurfaceアプリケーションではSegoe360が推奨されますが、常に個々のブランドやシナリオにフィットするわけではないかもしれません。</p>

<p>代替の書体を選択する際には、回転や視認性、適用性を考慮する必要があります。サンセリフ体（文字の端にある飾りがない書体のことです）は概してセリフ体（逆に飾りがある書体のこと）よりも推奨されます。わずかな飾りや横幅の一貫性、そして気前のよいナビゲーションスペース（？）が理由です。Surfaceに代替の書体を選定して使用する時は充分に注意してください。最終的な選考の前にSurfaceのディスプレイで可読性を必ずテストしてください。<br/><img src="http://taninno.github.com/images/surface/064.png" width="320"/></p>

<ul>
<li><p>アプリケーションの開発中、その前から、全てのアングルでテキストのレンダリングを評価してください。</p></li>
<li><p>全てのを大文字か小文字で使用するのは避けてください。文章の場合、大文字はより自然に、読みやすく、めったに挑戦的なトーンを伝えません。</p></li>
<li><p>セリフ体が視覚のブランドエクスペリエンスの無くてはならない一部であれば、可読性を高めるために30ptかそれ以上に設定してください。</p></li>
<li><p>ハイコントラストな植字は可読性を損ないます。黒背景に白い文章は縁がざらつき、かわいそうなリーディングエクスペリエンスとなります。</p></li>
<li><p>曲線状のパスに沿って文章を配置することは避けてください。</p></li>
<li><p>ほとんどのSurfaceのオブジェクトとコントロールは自由なスケールを持つことを忘れないでください。最小スケール限界を実行したオブジェクトは最大テキストの可読性を維持する必要が時々あります。</p></li>
<li><p>フォントレンダリングのテストをSurface自身で行うことの代わりはありません。読みやすさのテストは行わなければなりません。文章が回転や拡縮しているときもです。</p></li>
</ul>


<p>フォントサイズの最小の選択肢</p>

<ul>
<li><p>インターフェイス要素のラベルには12pt</p></li>
<li><p>本文や文章には16pt</p></li>
<li><p>軽い書体（薄いか狭い幅）には30pt</p></li>
<li><p>セリフ体（文字の線の終わりにある&#8221;拡張&#8221;を含むもの &ndash; ひげのこと）には30pt</p></li>
</ul>


<div id="section3-2-7"></div>


<h3>7. イコノグラフィー</h3>

<p>アイコンはエクスペリエンスを支えることができますが、使用する意図が必要です。</p>

<h4>a. 視覚的な手がかりとしてのアイコン</h4>

<p>アイコンは視覚的に機能を伝えることに役立ちます。ボタンや他のコントロールの機能は常にユーザーにとって明らかでは限りませんし、小さなコントロールの上でテキストラベルを使うことが常に適してるとは限りません。そのような場合には、シンプルでありながらアイコンはテキストボタンラベルの補足として使用することができます。40個以上のサンプルセットがSurface 2.0 SDKで配布されています。<br/><img src="http://taninno.github.com/images/surface/065.png" width="320"/></p>

<p>適切なダイレクトタッチインタラクションが可能である場合には、機能の手がかりとしてアイコンを使用したり、アイコンボタンを使用しないでください。例えば、ランチャーの隅に置かれた回転ボタンを配置するより、すでにランチャーは回転しやすくあります。ランチャーはユーザーに操作を促すために繊細な回転矢印を使用しています。</p>

<h4>b. カスタムアイコンの作成</h4>

<p>もしアプリケーションでサンプルアイコンに含まれていないアイコンが必要であれば、次のカスタムアイコン開発のガイドラインに従ってください。</p>

<ul>
<li><p>アイコンはシンプルな矩形でなくてはいけません。</p></li>
<li><p>アイコンは限らせた細かさでなくてはいけません。</p></li>
<li><p>アイコンは拡縮可能でなくてはいけません。</p></li>
<li><p>アイコンは現実世界のメタファーを利用しなければいけません。</p></li>
<li><p>アイコンは同じよう重量感でなくてはいけません。</p></li>
</ul>


<div id="section3-2-8"></div>


<h3>8. モーションデザイン</h3>

<p>モーションデザインはどのようにものがスクリーン上を動くのかを定義した、Surfaceのエクスペリエンスの重要な１つです。アニメーションは常にコンテンツと全体の体験をサポートします。モーションデザインは「アニメーション」と「感情、エネルギー、コネクションそして反応性を伝える効果」を提供します。それらは視覚的なヒント、行動を促すきっかけ、コンテンツの探索を招待することを提供します。</p>

<h4>a. トランジション</h4>

<p>トランジションは文脈を与え、ユーザーがどこにいるのかの視覚的なヒントを提供します。それらはユーザーが<a href="http://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%B3%E3%82%BF%E3%83%AB%E3%83%9E%E3%83%83%E3%83%97">メンタルマップ</a>を作成する助けになります。どのようにコントロールを使うのか、長く表示されていない時でも、スクリーン上のどこにオブジェクトがあるのかを忘れないために、トランジションは助けになります。<br/><img src="http://taninno.github.com/images/surface/066.png" width="480"/></p>

<p>トランジションはナビゲーションコンテキストを提供する深度を利用した幾つかのモード（アトラクト・ランチャー・アプリケーション）の間を移動するモデルとなります。例えば、ランチャーに入るためにアトラクトを離れたときに、アトラクトはZスペースを押しのけます（ランチャーの後ろに移動します）。ランチャーからアプリケーションを起動したときに、ランチャーはZスペースを戻り、アトラクトはもっと遠くに戻ります。これはユーザーに体験を通して移動する方法に関する重要な文脈を提供します。</p>

<p>トランジションの言語や機能や文字、スタイルが適したモデルを開発します。開発中のアプリケーションの種類を検討し、フィットして適したトランジションを作成してください。</p>

<p>ゲームで発生するトランジションは楽しく面白くあるでしょうし、健康管理アプリケーションでのトランジションは手短に簡潔であるべきでしょう。</p>

<p>トランジションがしなければならないこと：</p>

<ul>
<li>シームレスであること</li>
<li>意味を持つ</li>
<li>参考になる</li>
<li>適切である</li>
<li>時間に注意してください。コンテンツにアクセスするためだけに長いトランジションを強要させユーザーにフラストレーションを与えないでください。</li>
<li>前後関係のあるナビゲーションを用意してください。</li>
<li>アプリケーションの物語を強化してください。</li>
</ul>


<h4>b. 視覚的なヒントのためのトランジション</h4>

<p>モーションデザインはユーザーが観察を通して即座に学べるツールを提供します。チュートリアルや長ったらしいデモンストレーションを無しで。</p>

<p><img src="http://taninno.github.com/images/surface/067.png" width="280"/><br/>例えば、ランチャーが後ろのフェードインしてくるコンテナーをロードしている時に、アプリケーションアイコンはスライドし、背景のコンテナーの端に到達したらアプリケーションのアイコンは縮みます。ユーザーはこの動き見て、見えてるものよりもオプションがあることを理解します。スライドの動きはコンテンツがスクロール可能だということのヒントになります。</p>

<p>もし、ランチャーのコンテナーがスクリーン上にトランジションもなく突然現れたりしたら、難しくもないのに動かないように見えてしまいます。ユーザーにコンテンツが移動可能で、現在表示されているものよりも多くのオプションが使用可能だということを知らせることは難しいでしょう。そのため、視覚的に機能を示唆する方法のためにトランジションを使用することには、ともて価値があります。</p>

<h4>c. アニメーションのガイドライン</h4>

<p>アニメーションガイドラインはユーザーにどのようにしてタスクを達成するための特有のタッチ操作を行うのかを教えます。それらは、特定のボタンアイコンやコンテンツの一部で使われ、ユーザーへ視覚的にタスクを説明するためフィードバックを提供する方法を伝えます。<br/><img src="http://taninno.github.com/images/surface/068.png" width="380"/></p>

<p>例えば、アクセスポイントはユーザーに特定のタッチ操作を教えるためにアニメーションガイドラインを使用します。誰かがアクセスポイントをタッチしたとき、視覚的なインジケーターやアクションワードがアクセスポイントから外に動きます。もしユーザーがアクセスポイントをスライドするか、アクションワードをタップしたら、それらがSurfaceの次の体験へと誘導します。</p>

<h4>d. 周囲のアニメーション</h4>

<p>アンビエントアニメーションは、システムが生きて、起動、待機していることを示すために使用される繊細なアニメーションです。それらは、ブランドとアプリケーションの魅力を強化することができます。アンビエントアニメーションはあえて控えめで上品で、繊細で自然なエフェクトを使用します。<br/><img src="http://taninno.github.com/images/surface/069.png" width="380"/></p>

<p>背景の繊細なアンビエントアニメーションはSurfaceのエクスペリエンスに明るい本質を与えます。ユーザーにアプリケーションがレスポンスティブで動いていることを確実にするためにアンビエントアニメーションを使用してください。</p>

<div id="section3-3"></div>


<h2>セクション 3.3: サウンドデザインガイドライン</h2>

<p>Surface向けのサウンドデザインはSurfaceのデザイン原則から大きく引き出さなければいけません。アプリケーションでサウンドを使用するか作る場合に、次のガイドラインを忠実に守ってください。</p>

<ul>
<li><p>シンプルで繊細なサウンドにしてください。</p></li>
<li><p>サウンドが本当のデジタルであることを保証してください。</p></li>
<li><p>思慮深いサウンドを使用してください。サウンドはしばしば公共な場で聞こえづらいことがあります。もしサウンドが高圧的であったり、ユーザーの気に障るようであれば、ユーザーがスピーカーをミュートにするかアプリケーションを削除できるようにしてください。</p></li>
<li><p>サウンドはSurfaceShellやランチャーでのサウンドでも一貫性のあるボリュームにしてください。もしサウンドがアプリケーションのまっただ中で突然上がったら、ユーザーがスピーカーをミュートにするかアプリケーションを削除できるようにしてください。</p></li>
</ul>


<div id="section3-4"></div>


<h2>セクション 3.4: 言語と文章のデザインガイドライン</h2>

<p>Surfaceの体験は基本的にわずかなインターフェイステキストを要求しますが、これは開発しているアプリケーションにより変化するでしょう。文章はコンテンツ指向であり、思慮深く使用されるべきです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Post]]></title>
    <link href="http://taninno.github.io/blog/2012/08/02/post-title/"/>
    <updated>2012-08-02T00:36:00+09:00</updated>
    <id>http://taninno.github.io/blog/2012/08/02/post-title</id>
    <content type="html"><![CDATA[<p>test post</p>
]]></content>
  </entry>
  
</feed>
