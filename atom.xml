<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[taninnosorani blog]]></title>
  <link href="http://taninno.github.io/atom.xml" rel="self"/>
  <link href="http://taninno.github.io/"/>
  <updated>2013-09-22T11:40:39+09:00</updated>
  <id>http://taninno.github.io/</id>
  <author>
    <name><![CDATA[taninno]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Prototyperでモックアップ中心のワークフロー]]></title>
    <link href="http://taninno.github.io/blog/2013/09/12/justinmind-prototyper/"/>
    <updated>2013-09-12T23:28:00+09:00</updated>
    <id>http://taninno.github.io/blog/2013/09/12/justinmind-prototyper</id>
    <content type="html"><![CDATA[<p>モックアップツール、特にモバイル系に使用できるツールに関することを記載しています。</p>

<h3>Prototyper</h3>

<p>PrototyperはJustinmind社によるプロトタイピングツールです。プロトタイプツールにはproto.ioなどのWebブラウザが多いですが、Prototypeは珍しくスタンドアローンのデスクトップアプリです。</p>

<p><strong>Prototyper</strong><br/>
<a href="http://www.justinmind.com/">http://www.justinmind.com/</a><br/>
<img src="http://taninno.github.io/images/prototyper/prototyper.png" width="240"/></p>

<p>製品名にはプロトタイプ（“prototype”）が含まれていますが、製品に近い技術で作成されるプロトタイプというよりは、動きやコンポジションなどを確認するモックアップに近いと思います。目的としてはプロトタイプでは技術検証や非機能要件の検証、モックアップは主にUIの操作性の検証とUXの実現可能性を検証します。以降、言い方を分けて記載します。</p>

<ul>
<li><strong>モックアップ</strong>：一枚絵のハリボテをあたかも実際に動いているように見せて画面の操作感や画面間の遷移を確認する。デザインがあたっている状態ができれば好ましいが鉛筆で書いたラフスケッチを配置して確認することにも用いられる。例えば、パワポなどのツールでページにシェイプを配置してそれをプレゼンテーションモードでクリックしてページを移動させたもの、またはデザイナーがPhotoshopで作成した画面を画面遷移できるようにしたもの。ラピッドプロトタイプ。<br/>
<img src="http://taninno.github.io/images/prototyper/power.png" width="240"/><br/>
PowerPointでの使用イメージ<br/>
via : PowerMockup <a href="http://www.powermockup.com/">http://www.powermockup.com/</a></li>
</ul>


<br/>


<ul>
<li><strong>プロトタイプ</strong>：製品版と同じ技術を使用したプロダクトレベルでの確認用の成果物。場合によってはソースコードがそのままプロダクトに流用されることもあるが、そのような場合にはアーキテクチャレベルでの議論も含める必要がでてくるため注意が必要。モックアップとは違い一枚絵で表記されていたボタンなども製品と同じコンポーネントで、WebでればHTMLでCSSで装飾し、AndroidならレイアウトXMLで宣言する。そのため実際の開発で使用するIDEなどを使用することが多い。UIの検証というよりは非機能要件の検証の意味合いが強くなる。<br/>
<img src="http://taninno.github.io/images/prototyper/blend.png" width="240"/><br/>
Windows ストア アプリの画面作成イメージ<br/>
via : Visual Studio 2013 <a href="http://www.microsoft.com/visualstudio">http://www.microsoft.com/visualstudio</a></li>
</ul>


<br/>


<h3>モックアップツール</h3>

<p><strong>Designer’s Toolkit: Road Testing Prototype Tools</strong><br/>
<a href="http://www.cooper.com/journal/2013/07/designers-toolkit-proto-testing-for-prototypes">http://www.cooper.com/journal/2013/07/designers-toolkit-proto-testing-for-prototypes</a></p>

<p>アラン・クーパーさんのブログでプロトタイピングツール関するものがありますが、その中にPrototyperも取り上げられてます。注目なのは比較されている10個のプロトタイプツールのうちインタラクションの項目がHighなのはPrototyperとproto.ioの2つだけでした。</p>

<p><img src="http://taninno.github.io/images/prototyper/summaryChart.png" width="520"/><br/>
via : <a href="http://www.cooper.com/journal/2013/07/designers-toolkit-proto-testing-for-prototypes">http://www.cooper.com/journal/2013/07/designers-toolkit-proto-testing-for-prototypes</a></p>

<p>proto.ioもとても便利なプロトタイピングツール（これも本来はモックアップツールに近いと思いますが）です。ただWebブラウザ上で動作するため、個人では便利ですがある程度大きな規模の会社ではデスクトップアプリケーションである必要が出てくるかと思います。個人的にはproto.ioとPrototyperの2つがモックアップを作るなかで1番好きなツールです。どちらもインタラクションの設定が細かくできることが特徴です。</p>

<p><strong>proto.io</strong><br/>
<a href="http://proto.io/">http://proto.io/</a><br/>
<img src="http://taninno.github.io/images/prototyper/protoio.png" width="240"/></p>

<p>他には<a href="https://popapp.in/">POP</a>や<a href="https://www.flinto.com/">Flinto</a>もありますが、ワイヤーフレームの段階というよりもスケッチ段階で使用することが多くなります。まだUIを考え始めた段階で手軽にできるのが助かります。</p>

<p><strong>POP</strong><br/>
<a href="https://popapp.in/">https://popapp.in/</a><br/>
<img src="http://taninno.github.io/images/prototyper/pop.png" width="240"/></p>

<br/>


<h3>モックアップにはインタラクションが必要</h3>

<p>先のモックアップの説明ではPOPのような一枚絵を使用すると記載しましたが、Prototyperやproto.ioなどのインタラクションが設定できるツールを活用させてもらうことでモックアップ段階でもボタンやテキストフィールドなどのコンポーネントを操作可能な状態の画面をスマートフォンなどの実機で操作することができるようになります。</p>

<p><img src="http://taninno.github.io/images/prototyper/input.png" width="240"/><br/>
Prototyperのコンポーネントは実際に文字入力をすることもできます<br/>
via : Prototyper <a href="http://www.justinmind.com/">http://www.justinmind.com/</a></p>

<p>インタラクションを設定するのは少し手間ですが、このレベルでの画面操作を盛り込むことで、早期に実際の製品にとても近い操作でユーザーテストを実施することができます。これは実機で操作できることに意味があります。特にモバイルではスマートフォンのタップしやすい領域内にボタンがあるかどうかなどを確認する必要があります。そして画面がスクロールできることやタップしやすいかなどの基本的なUIの検証を行います。これをワイヤーフレームやプロトタイピングなどの少し工程が進んだ時に行っては、間違いに気付いたとしても手戻りが多くなってしまいます。</p>

<p><img src="http://taninno.github.io/images/prototyper/device.png" width="auto"/><br/>
PowerPointのような感覚でスクロール可能な実機のモックアップを作ることが出来ます<br/>
via : Prototyper <a href="http://www.justinmind.com/">http://www.justinmind.com/</a></p>

<h4>スケッチとワイヤーフレームの区別</h4>

<ul>
<li><strong>スケッチ</strong>：画面のイメージを紙に描いたもの。画面の要素を考察する。<br/>
<img src="http://taninno.github.io/images/post/sketch.jpg" width="180"/><br/>
スケッチのイメージ</li>
</ul>


<br/>


<ul>
<li><strong>ワイヤーフレーム</strong>：紙またはPowerPointやPhotoshopなどのツールで画面を書き表したもの。要素のレイアウトやサイズを考察する。<br/>
<img src="http://taninno.github.io/images/prototyper/wf2.png" width="140"/><br/>
ワイヤーフレームのイメージ<br/>
via : Putting it All Together: Wireframing the Example App <a href="http://developer.android.com/training/design-navigation/wireframing.html">http://developer.android.com/training/design-navigation/wireframing.html</a></li>
</ul>


<h4>それぞれの成果物の作成目的</h4>

<p>ローフィデリティ<br/>
↑<br/>
紙に手書きするスケッチ → 画面のアイディアを考察するため<br/>
ペーパープロトタイプ → 専門チーム内でのインタラクションの共通理解のため<br/>
一枚絵のモックアップ → ビジュアルを含めたインタラクションの早期確認のため（デザインが既にある場合のみ）<br/>
操作可能なモックアップ → UIの操作性の検証とUXの実現可能性を検証のため <br/>
ソースコードから作るプロトタイプ → 技術検証や非機能要件の検証のため<br/>
↓<br/>
ハイフィデリティ</p>

<br/>


<h3>モックアップ主導のアプローチ</h3>

<p>POPやFlintoをワイヤーフレーム段階で使用しないのは、実質的にワイヤーフレームをモックアップないしローフィデリティなプロトタイピングでまかなっているからです。ワークフローに関係することですが、動かないワイヤーフレームを書くよりはモックアップとしてテストもできる成果物を作成した方が効率が良いと思っています。なので、UIのスケッチの後はワイヤーフレームではなくモックアップの作成を行っています。この動かせる成果物のメリットに関しては私より長谷川さんの記事が分かりやすいとおもいます。</p>

<p><strong>触れる・動くによって変わるデザインプロセス</strong><br/>
<a href="http://www.yasuhisa.com/could/article/webdesign-and-prototyping/">http://www.yasuhisa.com/could/article/webdesign-and-prototyping/</a></p>

<p>少し昔はモックアップを作るのにFlashとActionScriptなどで工数がかかるために気軽に作るものではありませんでした。そのためワイヤーフレームというドキュメントを元にUIの議論が行われてきました。けれども今はPrototyperなどのツールを用いればFlashよりも簡単に早く作ることができるようになります。モックアップが作りやすくなったことでワイヤーフレームの作成の代替手段としてモックアップを選択可能になりました。どうせ作るのでしたら操作可能なワイヤーフレームのほうが関係者へのお披露目でも理解していただきやすくなります。</p>

<p><strong>Inspiring UI Wireframe Sketches</strong><br/>
<a href="http://webdesignledger.com/inspiration/inspiring-ui-wireframe-sketches">http://webdesignledger.com/inspiration/inspiring-ui-wireframe-sketches</a></p>

<p>上記の記事のように多くの方が綺麗な画面を描かれていますが、あまり効果的ではないと考えています。わざと雑に描くことはないですが、FireworksやPhotoshopでステンシルを配置するのに時間をかけるのであれば、Prototyperで配置するのと時間は変わらないと思います。同じボタンのステンシルを配置しても、Prototyperなら実機でタップできるボタンができあがります。</p>

<p><img src="http://taninno.github.io/images/prototyper/wf.png" width="240"/><br/>
画面を綺麗に描いてもUIの操作感は検証することができません。<br/>
via : Inspiring UI Wireframe Sketches <a href="http://webdesignledger.com/inspiration/inspiring-ui-wireframe-sketches">http://webdesignledger.com/inspiration/inspiring-ui-wireframe-sketches</a></p>

<p>動くものを作らなくても、パワポやPhotoshopなどで作った画面をペーパープロトタイピングすることもありますが、できれば早い時期にスケッチでおおよそのイメージが掴めてきたら、それを検証するためにも操作可能なモックアップを作成すると良いと思います。ペーパープロトはスケッチ段階中であれば自分またはチーム間の確認のためには有効だと思いますが、ユーザーテストに使用するには被験者に慣れと画面を想像するスキルが求められることになります。ユーザーに試していただくためにもスケッチを手短にして早めにモックアップに着手することが効率が良いと考えています。</p>

<p><img src="http://taninno.github.io/images/prototyper/sketch.png"/><br/>
スケッチは綺麗に書かず、これくらいレベルでモックアップに着手します。<br/>
via : 受諾UXアプローチ <a href="http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/">http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/</a></p>

<br/>


<h3>プロトタイピングのワークフロー</h3>

<p>UXプロセスを含めたモックアップのワークフローは以下の流れを考えています。</p>

<ol>
<li>理解</li>
<li>アイディア</li>
<li>ストーリー</li>
<li>UI</li>
<li>ビジュアルデザイン</li>
<li>開発</li>
<li>フィードバック</li>
</ol>


<p>上記のUIの中はスケッチや画面仕様書になります。</p>

<ol>
<li>スケッチ</li>
<li>モックアップ</li>
<li>画面仕様書（画面詳細設計）</li>
</ol>


<p>これまではモックアップではなくワイヤーフレームでした。仕様書に載せる画面はツールから出力したものを使用します。PrototyperではさらにWordやPDFへの画面仕様書の自動出力機能があります。フォーマットもカスタマイズできるので、手戻りがあっても画面仕様書の反映作業が大幅に短縮できます。</p>

<p><img src="http://taninno.github.io/images/prototyper/word.png" width="240"/><br/>
Wordへ出力する画面を選択できます<br/>
via : Prototyper <a href="http://www.justinmind.com/">http://www.justinmind.com/</a></p>

<p>（続く）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UXデザインアプローチ（受託UX寄り）]]></title>
    <link href="http://taninno.github.io/blog/2013/05/16/my-ux-design-approach/"/>
    <updated>2013-05-16T12:43:00+09:00</updated>
    <id>http://taninno.github.io/blog/2013/05/16/my-ux-design-approach</id>
    <content type="html"><![CDATA[<h2>UXデザインフロー</h2>

<hr />

<p><img src="http://taninno.github.io/images/post/ux.png"/></p>

<h4>目的</h4>

<p>受託のUXデザインを進めていく中で作業の流れと自分が気を付けてることをまとめました。基本的なフローは既存のUXプロセスやデザイン思考と変わりません。ただドキュメント指向のコミュニケーティングデザインを重視しています。
ここでのUXは受託開発で多い問題解決型のUXに関してになります。最近ではむしろ主流とされている顧客開発型のUXとは少し異なります。</p>

<h4>フェイズ</h4>

<ol>
<li>理解</li>
<li>アイディア</li>
<li>ストーリー</li>
<li>UI</li>
<li>ビジュアルデザイン</li>
<li>開発</li>
<li>フィードバック</li>
</ol>


<h4>参考手法</h4>

<ul>
<li>ゴールダイレクテッドデザイン

<ul>
<li>About Face 3 インタラクションデザインの極意</li>
<li><a href="http://hart.herokuapp.com/public/user/yk/book/39">http://hart.herokuapp.com/public/user/yk/book/39</a></li>
</ul>
</li>
<li>コミュニケーティングデザイン

<ul>
<li>Webサイト設計のためのデザイン&amp;プランニング</li>
<li><a href="http://hart.herokuapp.com/public/user/yk/book/46">http://hart.herokuapp.com/public/user/yk/book/46</a></li>
</ul>
</li>
<li>コンテキスチュアルデザイン

<ul>
<li>Contextual Design: Defining Customer-Centered Systems</li>
</ul>
</li>
<li>ワンページデザイン

<ul>
<li>シムシティ</li>
<li><a href="http://www.ea.com/sim-city">http://www.ea.com/sim-city</a></li>
</ul>
</li>
<li>Lean UX

<ul>
<li>Janice Fraser</li>
</ul>
</li>
<li>HCD/UCD

<ul>
<li><a href="http://www.hcdnet.org/">http://www.hcdnet.org/</a></li>
</ul>
</li>
</ul>


<h4>ご指摘大歓迎です</h4>

<p>twitter:@locationsdesign</p>

<!-- more -->


<h3>1.理解</h3>

<p>まずは課題（既知の問題や新規サービス）に対して、現在置かれている状況、展望、分析を行い、対象ドメインを理解したら、その人はどうされたいのか？を考えて、こうすればいいっていうアイディアが生まれたら、それをコンセプトにする。つまり理解していく中でアイディアは生まれてくる。アイディアを次のフェイズに区切っているのは、理解フェイズがアイディアを思いつくためにあるのと、アイディアを見える形に起こすためのフェイズと分けているため。</p>

<h4>目的</h4>

<p>ニーズや要件、問題点、環境、事情を理解し、アイディアを見つける。</p>

<h4>順序</h4>

<ol>
<li>クライアントとのヒアリング</li>
<li>顧客調査（業界調査・競合調査・ポジショニングマップ・4P分析・SWOT分析など）</li>
<li>ビジネスゴールの設定</li>
<li>ユーザ調査（定量的なアンケートからユーザーインタビューまで）</li>
<li>ユーザーゴールの設定</li>
<li>ペルソナの作成*</li>
<li>既存ユーザーのジャーニーマップの理解*</li>
</ol>


<h4>作業</h4>

<h5>1-1.クライアントとのヒアリング</h5>

<ul>
<li>最初に話を聞く時間をなるべく沢山とる。表向きのビジネスゴールのようなものから本音の社内ゴールや夢や愚痴などを出来る限り聞く。</li>
<li>最初にヒアリングとして2時間くらいの打ち合わせを設けるが、2時間ぐらいでは表層の部分の問題しか聞くことができない。ましてやNDAを結んでいるとはいえ、初対面の人には言い辛いことも多い。社内政治的な原因であれば尚更話せないだろう。そういった問題はある程度親密でなければ難しい。私はこのスキルが足りてないので感覚的に16時間以上くらい（週1回の2時間MTGの頻度であれば2ヶ月後）話を聞いていると本当の問題を理解できるようになる。</li>
</ul>


<h5>1-2.顧客調査</h5>

<ul>
<li>マーケティングのフレームワークなどが数多くあるので既に作成されているのであれば共有してもらう。特に数字はROIで目標達成のために必要になるので集取する。</li>
</ul>


<h5>1-3.ビジネスゴールの設定</h5>

<ul>
<li>カスタマーエクスペリエンスといったビジネス必要な情報、KPIやROIを理解することで後に生まれるアイディアがより具体的になる。その会社や組織、チームの特徴を活かしたアイディアにする。相手のことを理解しないで考えると、思いついたアイディアが競合他社でも成り立つアイディアになってしまう。もちろんそういうアイディアでも提案するが、それは今の会社からどれくらい離れいてることなのかを覚悟して言うのとでは、ただの突拍子もない意見に聞こえてしまう。</li>
<li>ビジネスモデルキャンバスを利用するのも良い。</li>
</ul>


<h5>1-4.ユーザ調査</h5>

<ul>
<li>実際のユーザーからのフィードバックや要望や苦情に目を通して、可能であれば対面でインタビューを行う。既にアンケートを実施している会社もあるが、実際にアンケートを参考されることも少ない。できれば生の意見があったほうがいい。</li>
<li>本来はユーザーに対して調査を行いたいが、時間がなければ社内のユーザーに聞いてみるもの有効だと考える。不満やアイディアは意外と多くの人が持っていたりする。そういった人たちに話を聞いてみるものUXデザインをする人の役割だと考える。</li>
</ul>


<h5>1-5.ユーザーゴールの設定</h5>

<ul>
<li>エンドユーザーであったり、既存のサービス内容であったり、受託UXならクライアントであったりを理解する。その人の気持ちを理解してその人になりきる。</li>
<li>ユーザーのニーズから直接的にゴールを設定しない。それでは対処療法的になってしまうので、新しい問題が出た時に、又は隠れた問題が合った際につじつまが合わなくなってしまう。なので、アイディアをコンセプトが複数の問題を解決する、という形にする。</li>
<li>UX受託の問題解決型なら「解決」することを考えて、顧客開発なら「自分が嬉しい」ことを考える。</li>
</ul>


<h5>1-6.ペルソナの作成 ＊（以下オプションにアスタリスクを付与）</h5>

<ul>
<li>もしペルソナを作っていたら普段から意識するために壁に貼り、常に見えるようにしておく。</li>
<li>個人的にはあまりペルソナのキャラクターを細かくしないほうが良い考える。又はフェイクペルソナを作るぐらいであればペルソナ自体を作らなくても良いと思う。ペルソナを作る目的はサービス提供者側がユーザーをもっと近くに意識するためにあると思う。細かいキャラクター設定をしたペルソナがあってもあまり説得力を持たない。

<ul>
<li><img src="http://taninno.github.io/images/post/persona.png" width="380" /></li>
<li>ペルソナで記載する最小プロパティ

<ul>
<li>簡単なシルエット写真</li>
<li>氏名（ニックネーム）</li>
<li>年齢（年代）</li>
<li>職業（業種単位）</li>
<li>既存サビースとのタッチポイント</li>
<li>既存サビースの利用頻度</li>
<li>既存サビースの利用目的</li>
<li>既存サビースのリテラシー</li>
<li>既存サビースへの要望</li>
</ul>
</li>
</ul>
</li>
<li>少ないキャラクター説明では理解されにくかったらポジショニングマップを添えると良い。ただ分かりやすいことでかえって問題も単純し過ぎてしまわないようにする。2軸のポジショニングマップは軸の選択と項目の配置が難しいため、参考程度の簡易的な資料と捉えたほうがいい。</li>
<li>できればLeanのように実際のユーザーをペルソナにしたほうが早く、納得もしやすい。ただそういったパートナーを見つけるのが難しければ簡単なペルソナを作り、サービスを作る目的がユーザーのためなのだと、思い返すために用意しておく。</li>
</ul>


<h5>1-7.既存サービスのジャーニーマップの理解 ＊</h5>

<ul>
<li>サービスの内容を理解し始めると、ユーザーとサービスの関わり方を一日の流れの中で図式する。これをジャーニーマップやUXマップなどに含まれるかもしれない。書いている途中でこのサービスでいいのかな？もっと先に提供すたほうがいいかな？と直したいところが出てくる。それは後々のアイディアに繋がってくるので違う色で囲ってメモしておく。</li>
<li>ここでのジャーニーマップは簡易的なスケッチであり、紙と鉛筆でアイディアを使用した場合のペルソナを行動させてみて、１日ないしサービスの適用期間内の問題点を見つけ出す作業である。プロットの前段階で行う。</li>
</ul>


<h4>成果物</h4>

<ul>
<li>業界調査</li>
<li>競合調査</li>
<li>ポジショニングマップ</li>
<li>ビジネスゴール</li>
<li>ユーザーやクライアントのメンタルモデル</li>
<li>ユーザーゴール</li>
<li>ペルソナ*</li>
<li>既存サービスのジャーニーマップ*</li>
</ul>


<h4>備考</h4>

<ul>
<li>アイディアを考えようとするのではなく問題の中にアイディアがある。だから問題や関係する人や環境を問診して、ずっとみていればいずれアイディアが出てくる。そういう意味では理解フェイズの時点でアイディアを考えて、アイディアフェイズはアイディアを視覚化するだけでもいい。</li>
<li>ヒアリングをしている段階でアイディアを思いついたり、ユーザー調査をしているときにジャーニーマップが書けてたり、ペルソナを作っているときにUIが浮かんできたり、先のフェイズの成果物が思いつくことはよくあり、良いことだと思う。あまり進行フローに囚われず場合によっては中間の作業も包括した成果物が作成可能であればスキップすることも場合によってはあったりする。</li>
</ul>


<br/>


<h3>2.アイディア</h3>

<p>見つけたアイディアをチーム（作業チームやプロジェクトチーム）内で方向性を一致させるためにコンセプト（関係図）を可視化し、共有する。</p>

<p><img src="http://taninno.github.io/images/post/concept.png" width="320"/></p>

<h4>目的</h4>

<p>アイディアを可視化する。</p>

<h4>順序</h4>

<ol>
<li>ブレストを開催する</li>
<li>アイディアを考える</li>
<li>コンセプトに作る</li>
<li>ビジョンを書く*</li>
</ol>


<h4>作業</h4>

<h5>2-1.ブレストを開催する</h5>

<ul>
<li>調査フェイズをやっていると個人個人でアイディアのネタを持ち始める。それをお披露目するためにブレストを行う。</li>
<li>ブレストなので関係者を集めて自由にディスカッションする。</li>
</ul>


<h5>2-2.アイディアを考える</h5>

<ul>
<li>ブレストをしてアイディアが集まったら、ビジネスゴールとユーザーゴールを両立するアイディアにしていく。</li>
<li>ビジネスゴールとユーザーゴールのどちらかしかなければ、またブレストのやり直しか調査フェイズの成果物を読み直しを行う。</li>
<li>考える問題の範囲を広くする。画面のUIだけで完結するのか？どこまでを変更すればいいのか？ユーザーの環境、考え方までを、受託でやることなの？ってぐらいまでを問題対象として広く考える。場合によってはちゃぶ台をひっくり返す。場合によってはここでサービス撤退さえも判断の対象となる。</li>
</ul>


<h5>2-3.コンセプトに作る</h5>

<ul>
<li>完璧だと思うアイディアが生まれたら可視化する。</li>
<li>コンセプトは絵や図、文章などその時に合いそうな表現にする。最近はアジャルのエレベーターピッチのように文章がブーム。電通のディレクターがやるようなラブレターのようなものでいい。けれどコンセプトは共有するためにあるので、分かりやすいものにする。必要があればインフォグラフィックにしてもいいかもしれない。</li>
<li>コンセプトはデザインブリーフのようにUXの方向性をチーム間で共有してブレないようにするためにある。なので作ったコンセプトは壁に貼っておく。シムシティのデザインアプローチを参考にする。</li>
</ul>


<h5>2-4.ビジョンを書く ＊</h5>

<ul>
<li>コンセプトはサービス内容を分かりやすく伝えるものだが、なぜそのサービスを提供するのか？そもそもなぜ提供するのか？などのもっと根本の部分を明記する。</li>
<li>当たり前のようになりがちだが、後のフェイズで方向性は常にブレる。その時のために前提となる価値観を共有するために事前に作成しておく。</li>
<li>既存のサービスにもユーザーに対してより良くしたいという想いがあって始めていることが多いと思う。理想的にも伝わりがちだが、達成したい想いがなければモチベーションを維持するのが難しくなる。もしビジネスゴール寄りの儲かるなどの利益を追求するだけであればUXアプローチである必要はなくなる。広告や広報にフォーカスすればいい。</li>
</ul>


<h4>備考</h4>

<ul>
<li>プロジェクト用の情報共有サイト（JIRAやBasecampなど）があるなら作成したアイディアなどを掲載する。コンセプトはトップページに配置するぐらいに。</li>
<li>以前はコンセプト後に要件定義フェイズを置いていたが、要件定義は機能要件を暗に含むことが多く、誤解を生みやすい。そのため要件定義は具体的なサービス内容が見えてくるストーリーフェイズの最終成果物とする。</li>
</ul>


<h4>用語</h4>

<ul>
<li>アイディア
: 相反しやすいビジネスゴールとユーザーゴールを両立させる解決策や戦略</li>
<li>コンセプト
: アイディアを分かりやすくキャッチコピーにしたもの</li>
<li>ビジョン
: ゴールを達成させたい気持ちを表した組織の目指すべきものを表したもの。ミッションまで記載するとややこしくなるので厳密には分けない。狭義の意味では先の「感動を伝えたい」はミッション的だがビジョンとしてまとめて記載している。</li>
</ul>


<h4>成果物</h4>

<ul>
<li>ブレスト</li>
<li>アイディア</li>
<li>コンセプト</li>
<li>ビジョン*</li>
</ul>


<br/>


<h3>3.ストーリー</h3>

<p>ユーザーの実際にどのようにしてゴールまで辿り着くかの流れを書き起こし、抽象的なコンセプトを具体的なサービス内容に落としこむ</p>

<h4>作業内容</h4>

<p>アイディアをシナリオによってサービス内容を具体化する。</p>

<h4>順序</h4>

<ol>
<li>プロットを構成する</li>
<li>シナリオを書く*</li>
<li>ジャーニーマップを描く*</li>
<li>ストーリーボードを描く*</li>
<li>機能要件をまとめる</li>
</ol>


<h4>作業</h4>

<h5>3-1.プロットを構成する</h5>

<ul>
<li>この時にはもうアイディアあり、場合によっては実装しているかもしれない。ただアイディアだけではサービスを構成するには不十分で、もっとサービスを膨らませるためにアイディアをペルソナに当てはめた１日（又は数年でも）を表にまとめる。</li>
<li>ユーザー（ペルソナ）が１日、もしかしたら数年を見越してそのサービスを使うことでメリットが何かを書き起こす。</li>
<li>アイディアが効果を持つのはピンポイントなことも多いので、ペルソナの1日をイメージしながら考えると、朝はこうするかもしれない！とか、ここでXXXが無い！などのジャーニーマップでは抽象的過ぎて気づかなかった点を思い起こさせる。</li>
<li>アイディアを膨らませて具体的なサービスにする。時間の流れの中でどこにサービスしたらいいかを考える。問題が出たり、しっくりこなかったらアイディアを考えなおす。</li>
<li>機能要件でまとめる具体的なサービスはここで現れてくる。</li>
<li>コンセプトが終わり、よし明日からシナリオを考えるぞ、ということにはならない。アイディアとシナリオは明確に区切れてるわけではなく、成果物として別であるだけある。アイディアを考えたらスイッチを入れ替えてすぐにシナリオに落としこむ。どんなシナリオも生まれる万能なコンセプトなんてものはない。

<ul>
<li><img src="http://taninno.github.io/images/post/plot.png"/></li>
</ul>
</li>
</ul>


<h5>3-2.シナリオを書く ＊</h5>

<ul>
<li>プロットを小説にしたものがシナリオになる。文章だけではなく、視覚化したジャーニーマップに含ませたり、4コマ漫画風にしたストーリーボードにしてもいい。どのアウトプットを使ってもアイディアがメリットを伝えられるようにする。</li>
<li>シナリオは現実的になって、本当にユーザーが使ってくれるかを結構シビアに考える。ここで楽観的になって間違えるとアイディアが「夢」で終わる。</li>
<li>以前はストーリーフェイズの最初の工程でシナリオを始めていたが、いきなりシナリオを作成するのは難しく、前段階で簡易なジャーニーマップと目次のようなプロットを用意する。</li>
</ul>


<h5>3-3.ジャーニーマップを描く ＊</h5>

<ul>
<li><p>ジャーニーマップには「体系的にタイムライン上のサービス構成をまとめた抽象的なもの」と「シナリオを視覚的に表現した個々の状況にフォーカスしたもの」の2種類があると考える。一般的なジャーニーマップは前者だと思うが、抽象的なジャーニーマップだけでは細かなところの誤解が生まれるかもしれないので、１人のペルソナと１つのメインシナリオをモチーフにした１つの体験を表す。</p>

<ul>
<li>前者

<ul>
<li><img src="http://taninno.github.io/images/post/former.png" width="320"/></li>
<li><a href="http://www.adaptivepath.com/ideas/the-anatomy-of-an-experience-map">http://www.adaptivepath.com/ideas/the-anatomy-of-an-experience-map</a></li>
</ul>
</li>
<li>後者

<ul>
<li><img src="http://taninno.github.io/images/post/latter.png" width="320"/></li>
<li><a href="http://suedesign4.wordpress.com/deliverables/task-3/">http://suedesign4.wordpress.com/deliverables/task-3/</a></li>
</ul>
</li>
</ul>
</li>
<li><p>thatgamecompanyのPS3「風ノ旅ビト」で書いたゲーム全体のユーザー体験の推移を表したものは後者のジャーニーマップに近いかもしれないが、マップという狭義の意味は場合によっては人と異なるのでイメージを確認しておく。</p>

<ul>
<li><img src="http://taninno.github.io/images/post/journey.png" width="420"/></li>
<li><a href="http://www.youtube.com/watch?v=S684RQHzmGA">http://www.youtube.com/watch?v=S684RQHzmGA</a></li>
</ul>
</li>
</ul>


<h5>3-4.ストーリーボードを描く ＊</h5>

<ul>
<li>文章だけのシナリオではイメージが膨らみすぎ、チーム内で認識齟齬が生まれれるかもしれない。そんなときはペルソナを登場人物にしたマンガにする。4コマ漫画のように1つのタスク・シナリオごとに作成する。</li>
</ul>


<h5>3-5.機能要件をまとめる</h5>

<ul>
<li>プロットで記載したサービスやシナリオの途中で気付いたサービスを機能要件として一覧にする。</li>
</ul>


<h4>用語</h4>

<ul>
<li>プロット: 「順番(Step)」「小見出し(Title)」「ユーザーの行動(UserAction)」「ユーザーが思ったこと(UserEmotion)」「必要なサービス内容(Service)」「備考(Memo)」の表を記載していく工程になる。必要であれば「イメージ写真」や「場所」、「タッチポイント」などの列も追記する。この後は小見出しを元にシナリオを記載するが、プロットのボリューム次第ではシナリオはスキップするかもしれない。</li>
</ul>


<h4>成果物</h4>

<ul>
<li>プロット</li>
<li>シナリオ*</li>
<li>ジャーニーマップ*</li>
<li>ストーリーボード*</li>
<li>機能要件（プロットのServiceが主に該当する）</li>
</ul>


<h4>備考</h4>

<ul>
<li>プロットやシナリオに対してストーリーボードは形式の違いなのでどちらを使用してもよい。差はそれほど現れないと思う。慣れた方を用いる。</li>
</ul>


<br/>


<h3>4.UI</h3>

<p>具体的な画面イメージを描く</p>

<h4>目的</h4>

<p>シナリオで提示したサービス内容をUIとして図式化する。</p>

<h4>順序</h4>

<ol>
<li>スケッチ</li>
<li>詳細画面設計</li>
<li>絵コンテ*</li>
<li>情報構成*</li>
<li>ガイドライン*</li>
</ol>


<h4>作業</h4>

<h5>4-1.スケッチ</h5>

<ul>
<li>ここのでスケッチは画面アイディアの出発となる荒い状態になる。プロジェクト全員に向けて見せるわけではないので、鉛筆とスケッチブックで落書き以上速記以下の精度で画面を書いていく。

<ul>
<li><img src="http://taninno.github.io/images/post/sketch.jpg" width="320"/></li>
</ul>
</li>
<li>画面と画面遷移は同時に進めていく。画面によって遷移を変更したり、遷移によって画面を変更することがある。</li>
<li>画面レイアウトの考え方の1ではあるが画面設計は演劇と同じように舞台の背景や大道具を決めるのに似ていると思う。同じように画面遷移は場面の切り替えになる。現実の制約に即すというわけれではなく、デジタルならではのインタラクションも効果的だが、舞台演出において観客を悪い意味で驚かすことは望ましくない。垂れてるロープを引っ張ったら上から出てくるべきで、トラップのように下の床が無くなったり、右から矢が出てくるようなことは推奨されない。</li>
<li>画面のインタラクションは画面のメンタルモデルに沿って考える。画面を演劇の舞台のように実際の空間があるように捉えて、役者と舞台装置がワープしないように気をつける。</li>
<li>簡単な画面ができたらすぐに他の画面と繋げて遷移を確認する。タスクのフローチャートを画面行うとどうしても思ったのと違う所がでてくる。実際のデバイスやマウス・タッチやってみなとわからない。PCのWebならパワポで図形にリンク貼るでもいいので、なるべく実機で確認する。</li>
<li>Leanやアジャイルで進めるならば、スケッチがある程度出来た段階で開発に着手することもあるかもしれない。小中規模開発向けとして生まれたアジャイルや、スタートアップは小規模のLeanにおいては少数精鋭のチームで組織されるならば、1pxの精度で指定されたワイヤーフレームでコミュニケーションする必要はあまりない。</li>
</ul>


<h5>4-2.詳細画面設計</h5>

<ul>
<li>一般的に、ワイヤーフレームと呼ばれるスケッチを綺麗にしたものは詳細画面設計の1つの要素として含まれる。スケッチはUIを考えるためにあるが、ワイヤーフレームはUIを誰かに伝えるためにあるため、説明や補足、遷移、又は全体の構成を含めた資料として作成する。Photoshopで作ったワイヤーフレーム単体では成果物とはならない。もし作る必要があっても、それはスケッチで十分のはずだと思う。</li>
<li>詳細画面設計には全体の画面構成（Webならサイトマップ）からヘッダー・フッターや基本レイアウト画面などの共通項目、そして各画面の詳細画面を記載する。</li>
<li>エラーなどのイレギュラーケースの表現もここで記載する。</li>
<li>ここでのワイヤーフレームはスケッチから見えてきた画面のコンポジションやレイアウトを清書する段階になる。ワイヤーフレームからはやり取りする対象が広がる。例えばビジュアルデザイナーに渡す資料としてワイヤーフレームが土台になるためある分かりやすくに描いておく。可能であれば専用ツールを使用することで効率が良くなるため、なるべく利用する。

<ul>
<li><a href="http://proto.io/">http://proto.io/</a></li>
<li><a href="http://uxpin.com/">http://uxpin.com/</a></li>
<li><a href="http://giveabrief.com/">http://giveabrief.com/</a></li>
<li><a href="http://www.infragistics.com/products/indigo-studio">http://www.infragistics.com/products/indigo-studio</a></li>
</ul>
</li>
<li>ただし、ワイヤーフレームは画面設計者とビジュアルデザイナー、デベロッパーが分業してるプロセスに置いては有効だが、画面設計者が画面デザイン、ないし開発も兼ねるのであればワイヤーフレームは必要性が無くなる。ただ１人で全てを行うのは難しいので、理想的なのはUXデザイナーがビジュアルデザインと開発がちょっと出来ることで、ワイヤーフレームを渡すよりも相手のフィールドに合ったファイル形式（デザインであればPhotoshop、開発であればView側のファイルなど）でバトンを渡せるといったことになる。</li>
</ul>


<h5>4-3.絵コンテ ＊</h5>

<ul>
<li>アニメは絵コンテをもとにレイアウトと原画を作るように、アプリケーションやサービスもアニメーションが関係する箇所には絵コンテを用意する。RIAやデスクトップアプリケーション、組み込みでは特にアニメーションによる演出が重要になる。ここでのアニメーションはインタラクションとも呼ばれるユーザーの操作にたいするフィードバックをインタラクションで返すことも含む。</li>
<li>インタラクションはすでにスケッチの段階で考察されている前提になる。ここではチーム間の共有や成果物としての提出の必要がある場合にこのタイミングに設定した。納品物としてだけの意味合いであれば後ろにずらしたほうがいい。</li>
<li>ここでのインタラクションは画面遷移やコンポーネントの詳細、アニメーションを記載した絵コンテのようなものになる。ワイヤーフレームの余白に描くこともあるが、量がある場合は専用のシートを用いて書き起こす。</li>
<li>インタラクションにはユーザーの待ち時間を短く感じさせたり、画面内の情報レベルを表示の順番やパターンで暗に知らせることも負う。画面遷移のトランジションもこれに含まれる。</li>
<li>絵コンテと言ってもプロが作るようなものではなくチラシの裏側で描くレベルで十分にある。</li>
</ul>


<h5>4-4.情報構成 ＊</h5>

<ul>
<li>詳細画面設計に入れるには規模が大きい場合には別添として、サイトマップのようなツリーマップを作成する。</li>
<li>追加のコンテンツがあっても上記に照らしあわせて、ふさわしい場所に配置する。</li>
</ul>


<h5>4-4.ガイドライン ＊</h5>

<ul>
<li>ワイヤーフレームを作成している段階である程度の共通項目が現れてくると思う。それを1つにまとめた資料がレイアウトガイドラインになる。量が少なく詳細画面設計に収まれば別添資料にしなくてもいい。</li>
<li>ガイドラインという主にはデザインの指向性を記載したグランドデザインガイドラインやLOOK&amp;FEELのようなボタンやアイコンなどのビジュアルを記載したデザインガイドライン、アプリケーションの挙動や振る舞いの方針をまとめたインタラクションガイドラインなどがある。</li>
<li>ただしルールが多くなると誰も守らなくなってしまう。やる気の問題ではなく、量が多いガイドラインは順守することが不可能になる。ガイドラインは暗記するものではなく、コンセプトやビジョンを汲み取ってもらうことが大切になる。ガイドラインをチェックリストとして扱うと破綻してしまう。</li>
</ul>


<h4>備考</h4>

<h4>成果物</h4>

<ul>
<li>スケッチ</li>
<li>ワイヤーフレーム</li>
<li>画面遷移図（サイトマップやフローチャートを兼ねる）</li>
<li>絵コンテ</li>
<li>IA</li>
<li>ガイドライン</li>
</ul>


<br/>


<h3>4.1.プロトタイプ（option）</h3>

<h4>目的</h4>

<p>具体的なサービス画面まで設計した段階で完成形のイメージの共有を行う。</p>

<h4>備考</h4>

<ul>
<li>ここはラピッドプロトタイプではなくて、ちゃんとしたものを作るイメージ。ラピッドプロトタイプ的なのは既にストーリーやUIのフェイズでモックアップなどのユーザーテストを行なっている前提とする。そのため、既にイメージが見えていればこのフェイズはスキップする。</li>
<li>大型案件であればステークホルダーが多いため、イメージ共有を目的とした実演を実施することを推奨する。</li>
<li>ここでのプロトタイプは技術調査を目的としない。技術調査はアイディアやUIの段階で（大変だが）検証している前提。R&amp;Dのような技術検証が目的である場合を除き、技術的に未検証のアイディアをこの段階まで進めない。アイディアやUIの実現性は技術者と常に確認を行う。</li>
<li>ペーパープロトタイピングではない。ペーパープロトタイピングは実際のデバイス上で確認するよりも精度が下がると考え推奨しない。現在はプロトタイピングツールを利用することにより、ペーパープロトタイピングと同じ時間コストで同等以上のモックアップを作成可能である。</li>
</ul>


<h4>成果物</h4>

<ul>
<li>プロトタイプ</li>
</ul>


<br/>


<h3>5.ビジュアルデザイン</h3>

<h4>目的</h4>

<p>ビジュアルイメージを具体的なアピアランスに移行する。</p>

<h4>備考</h4>

<ul>
<li>アイディアを話している時からおそらくビジュアルのイメージはできてるはずで、ここではビジュアルの広報性を議論するのではなく、スキンの開発を行う。</li>
<li>5番である必要はない。</li>
</ul>


<h4>成果物</h4>

<ul>
<li>アピアランスのスキン</li>
</ul>


<br/>


<h3>6.開発</h3>

<h4>目的</h4>

<p>コンセプト(UX)とUIを実現する。</p>

<h4>備考</h4>

<ul>
<li>開発まで1人でやるなら問題ないけど、誰かにお願いするなら遷移の時間感覚やアニメーションのフィーリングを身振り手振りで頑張ってわかるまで伝える。</li>
<li>小規模案件ではプロトタイプを飛ばし、ビジュアルデザインを並行する形で、UI設計段階の途中から開発に着手することもある。</li>
<li>リリース頻度を高くできるようにCI、デプロイ整備を行う。</li>
<li>良いプログラミングを行う。</li>
</ul>


<h4>成果物</h4>

<ul>
<li>継続的に提供可能なサービス</li>
</ul>


<br/>


<h3>7.フィードバック</h3>

<h4>目的</h4>

<p>提供可能になったサービスをフィードバックを得る</p>

<h4>備考</h4>

<ul>
<li>ユーザーリサーチ・ユーザーテスト・ユーザビリティテスト・A/Bテスト・サイト分析・コンバージョン率・SEO</li>
<li>Leanでは親しい顧客に先行して使用もらい、改善案を見つける。</li>
</ul>


<h4>成果物</h4>

<ul>
<li>改善案</li>
</ul>


<br/>


<h2>補足</h2>

<ul>
<li>2以降はいつでも1に戻り、3以降はいつでも2に戻り。（以下同じ）</li>
<li>アイディアやシナリオの時に技術調査や検証をいつでもできるように技術調査フェイズを予め予定しない。6.のプロトタイプは大型案件で全関係者へのお披露目の扱い。</li>
<li>ペルソナはあまり作りこまないで、ユーザーにサービス内容や成果物の出来を聞くようにする。</li>
<li>各工程で疑問や分からないことがあったらノートに書く。その疑問への考えと考えの流れをノートに書く。読み返した時に面白いし、たぶんチーム内の方向性の共有にも使える。WIKIでもbasecampでもyammerにしてもいい。</li>
<li>ユーザーテストの時期は特に規定しない。その時時の期間によって可能な限りのテストを実施する。</li>
<li>プロトタイプとテストのフェイズが独立しているが、試作とフィードバックは常に行う。ただ小回りがきかない受託型のUXでは常に行うのは現実的に難しく、予算の承認のためにも項目としてのこしている。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hart]]></title>
    <link href="http://taninno.github.io/blog/2013/02/18/hart/"/>
    <updated>2013-02-18T01:32:00+09:00</updated>
    <id>http://taninno.github.io/blog/2013/02/18/hart</id>
    <content type="html"><![CDATA[<h2>読書メモツール Hart</h2>

<p>自分の言葉で残していく読書の仕方をサポートするツールです。</p>

<p><a href="http://hart.herokuapp.com/">
<img src="http://taninno.github.com/images/post/hart.png" style="border:solid black 3px" width="480"/></a></p>

<p><a href="http://hart.herokuapp.com/">Hart</a></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generate Rails Command]]></title>
    <link href="http://taninno.github.io/blog/2013/01/17/rails-command/"/>
    <updated>2013-01-17T16:18:00+09:00</updated>
    <id>http://taninno.github.io/blog/2013/01/17/rails-command</id>
    <content type="html"><![CDATA[<h2>Railsのscaffoldコマンド生成ツール</h2>

<p>Scaffoldなどで型の打ち間違えを無くしたいので作りました。</p>

<p><a href="http://sheltered-stream-4127.herokuapp.com/">
<img src="http://taninno.github.com/images/post/001.png" style="border:solid black 3px" width="480"/></a></p>

<p><a href="http://sheltered-stream-4127.herokuapp.com/">Generate Rails Command</a></p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jenkinsでgit管理のWindowsPhoneをビルドする]]></title>
    <link href="http://taninno.github.io/blog/2012/08/15/windowsphone-on-jenkins/"/>
    <updated>2012-08-15T22:43:00+09:00</updated>
    <id>http://taninno.github.io/blog/2012/08/15/windowsphone-on-jenkins</id>
    <content type="html"><![CDATA[<ol>
<li><a href="http://jenkins-ci.org/">http://jenkins-ci.org/</a>でWindowsのやつをインストール。</li>
<li>gitやMSBuildとかのプラグインをインストールする。</li>
<li>jenkinsのPath to Git executableには「C:\Program Files\Git\bin\git.exe」を入れる。MSBuildのPath to MSBuildには「C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe」。</li>
<li>個々のジョブを作って設定で、Repository URLにローカルリポジトリだと.gitまでのフォルダパスを入れる。ブランチには今回はmasterを指定している。</li>
<li>ビルドの指定にはさっき登録したMSBuildを選択して.slnファイルへの相対パスを指定する。コマンドラインオプションには「/p:Configuration=Release /t:Clean,Build」を入れる。</li>
</ol>


<p>てかWindowsPhone関係ないのか…
でもこれでjenkinsでビルドが出来るはず。</p>

<h2>参考URL</h2>

<ol>
<li><a href="http://tech-old.hilife-jp.info/2011/12/silverlight-unittestjenkins.html">http://tech-old.hilife-jp.info/2011/12/silverlight-unittestjenkins.html</a></li>
<li><a href="http://kiita-it-blog.seesaa.net/article/249556782.html">http://kiita-it-blog.seesaa.net/article/249556782.html</a></li>
<li><a href="http://d.hatena.ne.jp/ch3cooh393/20120126/1327510696">http://d.hatena.ne.jp/ch3cooh393/20120126/1327510696</a></li>
<li><a href="http://blog.gigei.jp/tech/000053.html">http://blog.gigei.jp/tech/000053.html</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[開発環境について]]></title>
    <link href="http://taninno.github.io/blog/2012/08/11/current-environment/"/>
    <updated>2012-08-11T17:11:00+09:00</updated>
    <id>http://taninno.github.io/blog/2012/08/11/current-environment</id>
    <content type="html"><![CDATA[<p>こんな開発環境ができたらいいなのURLメモです。</p>

<!-- more -->


<h3>アジャイル</h3>

<p><a href="http://agilemanifesto.org/iso/ja/">http://agilemanifesto.org/iso/ja/</a><br/>
→開発環境ではありませんが以降のツールもスクラムでの開発が想定されていると思うので</p>

<h3>Pivotal Tracker</h3>

<p><a href="http://www.pivotaltracker.com/">http://www.pivotaltracker.com/</a><br/>
→スクラム向けスケジュール管理・バグ管理<br/>
　今年の初めの記事ですが、シリコンバレーで使われる開発環境として3位になったり上昇中です。
　<a href="http://japan.internet.com/wmnews/20120118/7.html">http://japan.internet.com/wmnews/20120118/7.html</a></p>

<h3>Jenkins</h3>

<p><a href="http://jenkins-ci.org/">http://jenkins-ci.org/</a><br/>
→継続的インテグレーション・自動ビルドシステム</p>

<h3>Coverity</h3>

<p><a href="http://www.coverity.com/html_ja/">http://www.coverity.com/html_ja/</a><br/>
→静的ソースコード解析（C#向け）</p>

<h3>Gerrit</h3>

<p><a href="http://developer.aiming-inc.com/ci/jenkins-gerrit-trigger-plugin-usage/">http://developer.aiming-inc.com/ci/jenkins-gerrit-trigger-plugin-usage/</a><br/>
→コードレビュー</p>

<h3>Bugspots</h3>

<p><a href="http://www.publickey1.jp/blog/12/bugspots.html">http://www.publickey1.jp/blog/12/bugspots.html</a><br/>
<a href="http://www.publickey1.jp/blog/11/post_193.html">http://www.publickey1.jp/blog/11/post_193.html</a><br/>
→バグ予測アルゴリズム</p>

<h3>Git</h3>

<p><a href="http://git-scm.com/">http://git-scm.com/</a><br/>
→SVNのようなバージョン管理システム<br/>
　WebサービスとしてはGithubがあります。<br/>
　<a href="https://enterprise.github.com/">https://enterprise.github.com/</a><br/>
　オンプレミスで使用するのであればgitlabがあります。<br/>
　<a href="http://gitlabhq.com/">http://gitlabhq.com/</a></p>

<p> 上記を全て組合せればかなり効率がいい開発が行えると思いますが
まずはちゃんとユニットテストを書かないといけませんよね。<br/>
<a href="http://ja.wikipedia.org/wiki/%E3%83%86%E3%82%B9%E3%83%88%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA">http://ja.wikipedia.org/wiki/%E3%83%86%E3%82%B9%E3%83%88%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA</a></p>

<p>また代替案としてTFSだけで結構実現できることも多いです。<br/>
<a href="http://tfspreview.com/">http://tfspreview.com/</a><br/>
→TFSだとDevOpsの運用に向いていますね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Microsoft Surface 2.0 Design and Interaction Guideline 翻訳]]></title>
    <link href="http://taninno.github.io/blog/2012/08/05/surface-guideline-reading/"/>
    <updated>2012-08-05T13:50:00+09:00</updated>
    <id>http://taninno.github.io/blog/2012/08/05/surface-guideline-reading</id>
    <content type="html"><![CDATA[<p><img src="http://taninno.github.com/images/surface/surface.png"/></p>

<p>Surfaceのデザインガイドラインを自身の理解のメモとして翻訳しています。翻訳の精度は高くありません。Surfaceの名称は「<a href="http://www.microsoft.com/en-us/pixelsense/default.aspx">Pixel Sense</a>」に改名されていますが、ここではガイドラインに従い旧名の「Surface」を使用しています。ガイドラインにはSurfaceの特色であるテーブル型ディスプレイのガイドラインが主な内容ですが、普遍的なインタラクションデザインに関する記載も多くあります。原書には画像付きで分かりやすく書かれているので是非読んでみてください。</p>

<p>Surface 2 Guideline PDF<br/>
<a href="http://www.microsoft.com/en-us/download/details.aspx?id=26713">http://www.microsoft.com/en-us/download/details.aspx?id=26713</a><br/>
Surface 1 Guideline PDF<br/>
<a href="http://www.microsoft.com/en-us/download/details.aspx?id=19410">http://www.microsoft.com/en-us/download/details.aspx?id=19410</a></p>

<br/>


<p>SurfaceSDKのセミナー資料も公開しています。</p>

<iframe src="http://www.slideshare.net/slideshow/embed_code/13097810?startSlide=9" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen webkitallowfullscreen mozallowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"></p>

<br/>


<p>目次</p>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section1">イントロダクション</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section2">はじめに</a>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section2-1">基本原則</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section2-2">重要事項</a></li>
</ol>
</li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3">デザインプリンシプル</a>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1">インタラクションデザインガイドライン</a>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-1">何人かの人と同じ時間を使った体験を作る</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-2">直接的なタッチインタラクション</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-3">体験を引き立てるために物質的なオブジェクトを使用する</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-4">常にタッチに反応すること</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-5">コンテンツに基づいた体験を作る</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-1-6">トランジションの注意</a></li>
</ol>
</li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2">ビジュアル＆モーションデザインガイドライン</a>

<ol>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-1">方向とレイアウト</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-2">深度</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-3">形状</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-4">テクスチャー</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-5">配色</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-6">タイポグラフィー</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-7">イコノグラフィー</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-2-8">モーションデザイン</a></li>
</ol>
</li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-3">サウンドデザインガイドライン</a></li>
<li><a href="http://taninno.github.com/blog/2012/08/05/surface-guideline-reading/#section3-4">言語と文章のデザインガイドライン</a></li>
</ol>
</li>
<li>SURFACE HARDWARE

<ol>
<li>INPUT METHODS</li>
<li>HARDWARE SPECIFIC CONSIDERATIONS</li>
</ol>
</li>
</ol>


<!-- more -->


<h1>Microsoft Surface 2.0 デザイン＆インタラクションガイド &ndash; デザインとアプリケーション開発の原則とガイドライン</h1>

<div id="section1"></div>


<h1>セクション 1.0: イントロダクション</h1>

<p>Sufaceは開発者とデザイナーがユーザーに驚きとソーシャル性とインタラクティブエクスペリエンスを提供することができます。ユーザーは360度全ての側面から互いのコラボレーションによって確かめ合いながら使うことができます。その信頼は堂々巡りの話し合いを止めるのに十分であり、直感的に老若問わずユーザーへ理解させることができます。（タッチやプッシュ、プル、ターン、スクリーンにオブジェクト置くことで？。）Surfaceはユーザーとコンテンツが相互に打ち解け触れ合っていく新しい機会を作ることができます。簡単に言えば、ユーザーが一緒に繋がり、学び、楽しみ、決定する簡単な方法はありません。Surfaceは常に直感的であり、有益であり、魅力的であり、助けになることを約束し、デザイナーと開発者がユーザーが探しだしたり覚えたりする体験を作ります。 説得力のあるSurfaceの体験を作るにはインターフェイスデザインとは異なるアプローチが必要です。このドキュメントはインタラクションとビジュアル、効果音、文章などを含むアプリケーションの主要な側面に関するデザインの原則とインターフェイスデザインのガイドラインを提供します。</p>

<div id="section2"></div>


<h1>セクション 2.0: はじめに</h1>

<p>以降のセクションでは、Surfaceアプリケーションを計画する上で心に留めておくための重要な事柄をハイライトします。</p>

<div id="section2-1"></div>


<h2>セクション 2.1: 基本原則</h2>

<p><strong>楽しさ</strong><br/>
魅惑的な、驚くべき、報われる<br/>
Surfaceは触覚や視覚、聴覚に繋がることでレスポンスと心を捕らえることでユーザーの好奇心に報います。</p>

<p><strong>スマート</strong><br/>
直感的な、精通した、鋭敏な<br/>
Surfaceはユーザーの次の動きを予測します。それは必要な時にタイミング良く明らかにされる重要な情報と上記で誘導します。</p>

<p><strong>控えめな</strong><br/>
優雅な、繊細な、魅力的な<br/>
Surfaceはユーザーがおもてなしと機転を通して体験する中に含まれる可能性を理解することを手助けします。</p>

<div id="section2-2"></div>


<h2>セクション 2.2: 重要事項</h2>

<h3>1. ピクセル対インチ</h3>

<p>Surfaceハードウェアは下記を公開します。</p>

<p>Microsoft.Surface.Input.InteractiveSurfaceDevice.PhysicalScaleTransformproperty.</p>

<p>このプロパティは96dpiとSurfaceのユニットで使用される論理的dpiの間の比率を表します。この変換を使えば、96picelはディスプレイで１つの実際のインチになります。LogicalDpiXとLogicalDpiYのプロパティも公開しています。それらはSurface上で表示された1インチのピクセル数を返します。</p>

<p>それらのプロパティは、UIElementが似たような物理的ディスプレイサイズを持っても、たとえどんなSurfaecデバイスが使われているかに関係なく開発者がアプリケーションを作ることを許可します。このプロパティはスクリーンサイズか解像度に関係なく、適切なサイズのコンテンツを持つアプリケーションを設計する際の手助けとなります。</p>

<p>免責事項：デフォルトの96dpiが想定されるハードウェアのタイプである場合には、全てのディスプレイが実際のピクセルサイズを公開しているわけではありません。</p>

<h3>2. 国際化とローカライズ</h3>

<p>Surfaceアプリケーションは世界中の言語と地域が用意されています。グローバルマーケットで自社のアプリケーションを販売する開発者は国際化が準備されていることを確認してください。アプリケーションインターフェイスは様々なテキスト長や日付形式をサポートするベストプラクティスな設計に従ってください。そして色彩や画像、地政学的な問題の使用にあたっては文化的感性を心がけてください。MSDNオンラインではそれらのベストプラクティスを扱う様々なトピックを持っています。</p>

<p>一般的に、ローカライズされた文字列に対して少なくとも40%のバッファスペースを提供すべきです。</p>

<h3>3. ユーザーの理解</h3>

<p>Surfaceアプリケーション開発より前に、アプリケーション開発者やデザイナーはどんなアプリケーションを開発することが使われることが多いか、そしてビジネスゴールを理解することが大切です。</p>

<div id="section3"></div>


<h1>セクション 3.0: デザインプリンシプル</h1>

<p>デザインはSurfaceのエクスペリエンスの重要な部分です。Surfaceアプリケーションはコンテンツが常に体験の中心であることを保証することを手助けする特別な一連の原則に基づいています。<br/>
顧客の要件と実装はアプリケーションによって異なってきます。そのため開発者がアプリケーションのデザインとスタイルの土台としてのプリンシプルの使用が強く推奨されます。Surfaceのデザインプリンシプルは人々を引き付ける一貫して楽しい体験を作るスタートポイントとして使用すべきです。Surfaceアプリケーションは次の5つのプリンシプルからデザインされています。</p>

<h3>1. Simple (Light and open)</h3>

<p><strong>Surfaceの体験は過度に飾り立てたり装飾しません。</strong><br/>
とてもシンプルで単純なエクスペリエンスの開始アイコンはSurfaceの開始の位置を誘導しています。遊び心のある有機的なアトラクトモード（以下の図の待機画面のこと）とは対照的に、写実的でミニマルな開始アイコンはそれがナビゲーションポイントであることを指し占めています。</p>

<p><img src="http://taninno.github.com/images/surface/001.png" width="240"/></p>

<h3>2. Organized (Hierarchical and structured)</h3>

<p><strong>最も大切な要素は最も視覚が重要です</strong><br/>
Surfaceのランチャーは視覚的にアプリケーションのアイコンやタイトル、説明文にフォーカスできるように整理、構造化されています。このランチャーは繊細で（いくつかの背景に配置した際に？）組織的な本来の意味を持続させます。</p>

<p><img src="http://taninno.github.com/images/surface/002.png" width="240"/></p>

<p>vai:Working with Visual Weight in Your Designs<br/>
<a href="http://sixrevisions.com/graphics-design/visual-weight-designs/">http://sixrevisions.com/graphics-design/visual-weight-designs/</a></p>

<h3>3. 本当のデジタル（いつも通りに誠実に）</h3>

<p><strong>Surfaceは適切な時だけ物理世界をエミュレートし、誠実にデジタルメディアを反映させたデザインスタイルを使用します。</strong><br/>
アトラクト状態は現実世界と水のインタラクションに基づいています。それは通常実現可能な現実世界に装飾されたデジタルな粒子と鮮やかな反射を加え、デジタルメディアに忠実な体験を作り出します。</p>

<p><img src="http://taninno.github.com/images/surface/003.png" width="240"/></p>

<h3>4. コンテンツ指向</h3>

<p><strong>コンテンツはいつも体験の中心にあります。コントロールと装飾は二の次です</strong><br/>
以下の図に示す写真コンテンツはエクスペリエンスの最も大切な部分です。エレメントメニューインジケーター（コンテキストメニューのようなもの）は写真に触れた時にのみ表示します。ユーザーはエレメントメニューのアイコンをタッチした時に選択肢を出すことができます。</p>

<p><img src="http://taninno.github.com/images/surface/004.png" width="240"/></p>

<h3>5.Lively (Soulful and responsive)</h3>

<p><strong>Surfaceは常に反応がよく、アニメーションやモーションはコンテンツをより良くし、コンテンツにスクリーン上で活力をもたらします。</strong><br/>
Surfaceのトランジションは体験を生き生きさせます。ここに示すアプリケーションのローディングトランジション（原書でアプリケーションの起動ローディングを指している）はSurfaceが起動に反応している方法を説明します。アプリケーションアイコンはユーザーの指の下で僅かに拡大し、ランチャーは縮小し、ぼやけ、そしてローディング進行率を示すためにローディングバーがアイコンの下に現れます。</p>

<p><img src="http://taninno.github.com/images/surface/005.png" width="240"/></p>

<div id="section3-1"></div>


<h2>セクション3.1 : インタラクションデザインガイドライン</h2>

<p>インタラクションデザインはユーザーの振る舞いや反応、タッチ、動きを持ったソフトウェア体験の相互作用を定義します。それらのインタラクションガイドラインは直感的で魅力的な均一のSurfaceアプリケーションを作る上で包括的な全体像を含むデザイン原則と関連しています。<br/>
プリンシプルの中にある相互関連性の重要な取り決めがあります。けれど、ガイドラインのどの程度の重要性かは、作成したアプリケーションのタイプによって決まります。</p>

<div id="section3-1-1"></div>


<h3>1. 何人かの人と同じ時間を使った体験を想像する</h3>

<p>Surfaceは50箇所以上のタッチを同時に認識して反応します。それは指やオブジェクトスクリーンをタッチした際にわかります。これは何人かの人々をSurfaceの周りに集めたり、アプリケーションを共有したり、孤独な活動をソーシャルな体験に向上させることを可能にしています。</p>

<h4>a. 360度の水平展開のアプリケーションデザインを使用する</h4>

<p>Surfaceはタッチの方向を認識します。指の方向とオブジェクトがはいちされている位置がスクリーンとの接触によってわかります。開発者が特定の人がスクリーンのどちら側なのかを判断することができます。</p>

<ul>
<li><p>ディスプレイの一方方向だけから向かい合うことを避けて、全員がコンテンツを使えるようにしてください。<br/><img src="http://taninno.github.com/images/surface/006.png" width="240"/></p></li>
<li><p>ユーザーはコンテンツの正面を変えることができます。画面の特定の方向にコンテンツをロックしません。</p></li>
<li><p>Surface2.0 SDKのSacatterViewコントロールを使うことは360度の体験をすぐに可能にします。<br/><img src="http://taninno.github.com/images/surface/007.png" width="140"/></p></li>
<li><p>全ての人がアプリケーションの主要要素に全ての方向から確実に届いて使えるようにします。<br/><img src="http://taninno.github.com/images/surface/008.png" width="240"/></p></li>
<li><p>いくつかの顧客向けアプリケーションではユーザーに対して特別なスクリーンの方向が要求されるかもしれません。これは一般的にアプリケーションのユーザービリティを制限しますので、慎重に検討してください。<br/><img src="http://taninno.github.com/images/surface/009.png" width="240"/></p></li>
<li><p>例えば、共同販売（？）アプリケーションは販売員が常に筐体の近くにいて、顧客は常に反対側にいることが要求されるかもしれません。これは顧客の初期のニーズを満足させるように見えるかもしれませんが、社会的なアピールを制限させるように、アプリケーションを低下させます。</p></li>
<li>インターフェイスはSurfaecの全ての方向から本当にアクセスできます。様々な方向でアプリケーション開発の開始からアプリケーションを使用とテストから始めます。たくさんの人々が同じ時間をテストプロセスを通してアプリケーションを共有することを保証します。</li>
<li><p>もし方向が自由なアプリケーションだったら（天地を持っていなかったら）、ユーザーはアプリケーションの中で天地を変えることができます。<br/><img src="http://taninno.github.com/images/surface/010.png" width="140"/></p></li>
<li><p>Surfaceアプリケーションはユーザーが使用する新しいコンテンツとインターフェイス要素に向かい合わなくてはいけません。開発者は指の方向とコンテンツの方向を使用して、コンテンツと要素をポイントに関する妥当な前提をコントロールします。</p></li>
<li><p>もしアプリケーションがまだ天地の方向を持っていたらユーザーにアプリケーションの方向を変える方法を提供します。<br/><img src="http://taninno.github.com/images/surface/011.png" width="240"/></p></li>
<li><p>簡単なflipボンタはユーザーが誤って触ってしまいやすく、体験が台無しになります。Surfaceランチャーはサイドのハンドルが、グループ化されたコンテンツが回転する前にユーザーに簡単に慎重に実行することを要求します。<br/><img src="http://taninno.github.com/images/surface/012.png" width="240"/></p></li>
</ul>


<h4>b. 垂直に設計された180度のアプリケーションを使用する</h4>

<p><img src="http://taninno.github.com/images/surface/013.png" width="240"/></p>

<ul>
<li>新しいコンテンツとインターフェイス要素をスクリーンの下を向いて、正しい位置に置きます。</li>
<li><p>新しいコンテンツが上下のある物体に見えるようにしてください。<br/><img src="http://taninno.github.com/images/surface/014.png" width="240"/></p></li>
<li><p>人々がどのように水平スペースを使うのかを理解してください。</p>

<ul>
<li>水平設定のスクリーンスペースは何人かの同時に使用するユーザーのためにカラムを区切られます。</li>
</ul>
</li>
</ul>


<h4>c. ユーザーがどのようにスクリーンのスペースを使用するのか理解する</h4>

<p>アプリケーションはひとりのユーザーが見たり、探したり、コンテンツを触ったりすることよりも簡単に多くのユーザーが同時に使える設計にします。</p>

<ul>
<li><p>重要なアプリケーション全体の変更が発生した際に、誰の目にも明らかにします。<br/><img src="http://taninno.github.com/images/surface/015.png" width="240"/></p></li>
<li><p>ユーザーのタッチインタラクションが突然他のユーザーエクスペリエンスに影響しないことを確認してください。</p>

<ul>
<li>例えばペイントアプリケーションで、一人のユーザーが消しゴムコントロールを選択したら、全員のタッチが予期せずにコンテンツを消し始めたとしたら問題です。</li>
</ul>
</li>
<li><p>ユーザーが動かしたりコントロールを使えるようにします。ディスプレイの片側に共有コントロールを接続しないでください。<br/><img src="http://taninno.github.com/images/surface/016.png" width="240"/></p></li>
<li><p>配置によってコンテンツの所有をはっきりさせます。もし新しいコンテンツが特定のユーザーに所属したらスクリーンのユーザーの前に配置してしてください。もしグループ共通コンテンツの部分だったら中央に配置してください。<br/><img src="http://taninno.github.com/images/surface/017.png" width="240"/></p></li>
</ul>


<h4>d. 異なるコラボレーションレベルの違いをサポートします</h4>

<p>3つの異なるコラボレーションのレベルがあります。</p>

<ul>
<li><em>高度に協力的な</em>：ユーザーは同じタスクを互いに助けあいゴールを達成します。</li>
<li><em>やや協力的な</em>：ユーザーはゴールを達成するためにタスクを分けて作業する。これは分割統治法として知られています。<br/>
via:<a href="http://e-words.jp/w/E58886E589B2E7B5B1E6B2BBE6B395.html">http://e-words.jp/w/E58886E589B2E7B5B1E6B2BBE6B395.html</a></li>
<li><em>協力を必要としない</em>：ユーザーは異なるゴールを達成するために別々のタスクに従事します。</li>
</ul>


<p>あなたのアプリケーションでどのようにして異なるコラボレーションを最高のサポートを行うかを理解してください。</p>

<ul>
<li>何人かのユーザーが同時にコンテンツとコントロールを使えるようにしてください。

<ul>
<li>全員が共通コントロールを使うことを要求したとしても進行を止めないでください。</li>
</ul>
</li>
<li><p>機能要素エリア毎にスクリーンを分けないでください。<br/><img src="http://taninno.github.com/images/surface/018.png" width="240"/></p></li>
<li><p>アプリケーションが特別なタスクを実行するために一方の側面を指定し、他の側面には違う機能を指定する時には紛らわしくなります。</p></li>
</ul>


<h4>e. ユーザーがどのようにアプリケーションを実行するのか理解します</h4>

<p>Surfaceは多くのユーザーが同時に使用できるように最適化されていまが、アプリケーションは１人のユーザーにとっても使えるように設計すべきです。特定の人がアプリケーション使えるようにさせ、他の人へ体験を共有するために参加を促すことができます。</p>

<ul>
<li><p>何人かのユーザーが機能的に影響しないことを保証します。</p>

<ul>
<li>１人のユーザーが他のユーザーの参加無しでもエクスペリエンスを楽しみことができるようにします。</li>
<li>新しいユーザーが参加しても、既にアプリケーションを使っているユーザーを中断させないで参加できるようにします。<br/><img src="http://taninno.github.com/images/surface/019.png" width="240"/></li>
<li>１人のユーザーが他のユーザーの体験を中断せずに離脱しても少数の人数が継続できることを確認してください。</li>
</ul>
</li>
<li><p>体験を想像します。それはユーザーが同時にシェアした時の何人かの人と一緒に生き生きとする経験は楽しく、効果的です。</p></li>
<li>適切な場合、ユーザーのタスクを分けたり、ユーザー自身が協業か異なるゴールの達成のためにスクリーンをシェアするかどうかを決めることができるようになるかもしれません。</li>
</ul>


<div id="section3-1-2"></div>


<h3>2. 直接的なタッチインタラクションの使用</h3>

<p>マウスとキーボードのGUIとは対照的に、Surfaceはコンテンツを操作するためにタッチとジェスチャーを使用します。直接的なタッチインタラクションはすぐにユーザーがすぐさま直感的に自身の操作フェードバックを理解することを助け、ユーザーをそれらの体験に通じやすくします。間接的にコンテンツを操作するためにハードウェアかソフトウェアボタンの使用は大概、ユーザーに同じ感覚を与えません。</p>

<h4>a.直接的なタッチインタラクションと間接的なタッチインタラクション</h4>

<p>直接的なタッチインタラクションは指か物理的なオブジェクトによってアプリケーション内の仮想コンテンツの物理的な運動である。直接的なタッチインタラクションは常にアプリケーションのChrome（表層）と抽象的なジェスチャーを信頼しています。例えば、間接的なタッチインタラクションはボタンやスライダー、メニュー、シンボルを描画するジェスチャーを含むことができます。直接的なタッチインタラクションはSurface内での使用ではインタラクションの型を好みます。それはそれらのインタラクションがエクスペリエンス指向のコンテンツをより直感的に想像することを助けるからです。  <p>標準的な直接的なタッチインタラクションを再定義してはいけません。常に正しい結果を生むSurface SDKの処理プロセッサーを使用してください。</p></p>

<ul>    <li>移動：項目の上で１本かそれ以上の指で移動かフリックができること<br/><img src="http://taninno.github.com/images/surface/020.png" width="240"/></li>
    <li>外へのリサイズか拡大：項目の上で２本かそれ以上の指で別々にドラッグする<br/><img src="http://taninno.github.com/images/surface/021.png" width="240"/></li>
    <li>内側へのリサイズか縮小：項目の上で２本かそれ以上の指で一緒にドラッグする<br/><img src="http://taninno.github.com/images/surface/022.png" width="240"/></li>
    <li>１本指での回転：項目を１本指でタッチして、円を回転できるように巡ってぐるりとドラッグする<br/><img src="http://taninno.github.com/images/surface/023.png" width="240"/></li>
    <li>２本指での回転：項目の上で２本以上の指で、相反する方向に弧にそってドラッグする<br/><img src="http://taninno.github.com/images/surface/024.png" width="240"/></li>
    <li>ピンターン：１つの指を残して、もう一つの指を旋回させる。<br/><img src="http://taninno.github.com/images/surface/025.png" width="240"/></li>
</ul>


<ul>
<li>直接的なタッチインタラクションを置き換えるために装飾やコントロールを使用しないでください。

<ul>
<li>例えば、アイテムを回転させるための回転ボタンを使用しないでください。<br/><img src="http://taninno.github.com/images/surface/026.png" width="240"/></li>
</ul>
</li>
</ul>


<h4>b.一本指でドラックやフリックを可能にする</h4>

<ul>
<li>全ての移動可能なコンテンツは一本指でドラックやフリックのインタラクションを可能にしてください。</li>
<li>一貫性のあるドラッグやフリックは、全てのコンテンツが常に基本的なのインタラクション操作ができることをユーザーに明確にさせます。</li>
</ul>


<h4>c.タッチ向けのアプリケーションの設計</h4>

<ul>
<li>インタラクティブな要素は指やオブジェクトにとって適切なサイズでなければいけません。

<ul>
<li>幾つかのアイテムはユーザーのタッチに反応します。タッチの対象となるものは少なくとも18mmの縦横のサイズであるべきです。<br/><img src="http://taninno.github.com/images/surface/027.png" width="140"/></li>
<li>タッチ対象の間は少なくとも3mmの間を持たせます。<br/><img src="http://taninno.github.com/images/surface/028.png" width="140"/></li>
<li>インタラクションな要素は手や腕やオブジェクトがスクリーンを覆ってインタラクション要素を持つ関連のあるコンテンツを妨げないように配置します。<br/><img src="http://taninno.github.com/images/surface/029.png" width="240"/></li>
</ul>
</li>
</ul>


<h4>d.マルチタッチへの応答</h4>

<ul>
<li>Surfaceは同時に50箇所以上のタッチを認識して反応します。</li>
<li>アプリケーションはマルチタッチに反応しなければなりません。</li>
<li>ユーザーはあらゆる体験においてマルチタッチのインタラクションが使用出来ると予期します。それはアプリケーションの自身の場所だけとは限りません。</li>
</ul>


<div id="section3-1-3"></div>


<h3>3. 体験を引き立てるために物質的なオブジェクトを使用する</h3>

<p>連続して途切れないサーフェイスの体験がフィジカルとバーチャルな世界を融合させることによって、ユーザーは没入することになります。</p>

<h4>a. タグオブジェクトの使用</h4>

<p>Surfaceの主要な差別化要因として、物体の認識機能があります。オブジェクトはユーザーがアプリケーションの体験に繋がることを手助けします。この方法は昔ながらのUIでは不可能です。
システムが素早く正確に認識することを助けることができる特別なオブジェクトを配置します。タグは赤外線を吸収したりエリアを取り込む幾何学的な配列から成り立つユニークなパターンです。タグオブジェクトがスクリーンに置かれた時、ビジョンシステムはタグを読み取り、値や位置、方向を決定します。</p>

<ul>
<li>共有や自身のスペースを向上させるためのオブジェクトの使用

<ul>
<li>例えば、教育アプリケーションはオブジェクトを各生徒のレッスンの進捗を割り当てるためにオブジェクトを使用するでしょう。</li>
</ul>
</li>
<li>はしゃいだり愉快な体験のためのオブジェクトの使用

<ul>
<li>例えば、ゲームの駒は異なる駒に様々なアニメーションを与えます。プレイヤーがスクリーン上に駒を配置した時、タグがプレイを促すアニメーションを引き起こします。</li>
</ul>
</li>
<li>ユーザーと他のユーザーとのフィジカルな設定を作るためにオブジェクトを使用する。</li>
</ul>


<p>タグ付けされたオブジェクを利用するアプリケーションがすべきこと</p>

<ul>
<li>タグオブジェクトにすぐさま反応する。</li>
<li>この即座の反応はユーザーにデバイスが動いていることを知らせます。</li>
<li>視覚的な反応を作ることはオブジェクトに適しています。</li>
<li>バーチャルな効果を伴った明確な物質的なオブジェクトとの繋がり（？）<br/><img src="http://taninno.github.com/images/surface/030.png" width="240"/></li>
<li>体験を強化して裕福にするオブジェクトの使用は、タグオブジェクトの存在を必須にしてはいけません。</li>
<li>赤外線を反射しないオブジェクトの使用はアプリケーションとの接続ができません。<br/><img src="http://taninno.github.com/images/surface/031.png" width="240"/></li>
<li>もしオブジェクトの赤外線反射が要求される場合、これらの連絡先をフィルタリングするために、オブジェクトの位置や形の知識を使用します。</li>
</ul>


<h4>b. 非タグオブジェクトの使用</h4>

<p>非タグオブジェクトはブログ（Blob）として参照されます。Surfaceはスクリーンに置かれた赤外線（IR）を反射するオブジェクトを見つけることができます。非タグオブジェクトからのコンタクトは、例えば全ての手がスクリーンに置かれた場合にブロブとして登録された他のオブジェクトからのコンタクトと同じになります。</p>

<p><img src="http://taninno.github.com/images/surface/032.png" width="240"/></p>

<p>アプリケーションは非タグオブジェクトを以下のように利用すべきです。</p>

<ul>
<li>非タグオブジェクトの存在に直ぐ反応してください。この機敏な反応でユーザーにデバイスが動作していることを知らせられます。</li>
<li>スクリーンにオブジェクトが置かれたら常に視覚的なサインで認識していることを表示してください。たとえそれが特別なものでなくとも。</li>
<li>ブロブプロパティからオブジェクトの形やサイズを特定できるとことを期待しないでください。全てのオブジェクトの形は楕円形で、サイズは赤外線が反射したオブジェクトの一部を示しています。</li>
</ul>


<h4>c. 物質的なオブジェクトであるかのようにみせる</h4>

<p>スクリーンではオブジェクトは移動中の微かな物理特性や運動の慣性、自然な感じの衝突で、矛盾の無い感覚を作ることを助けるべきである。</p>

<ul>
<li>現実の操作から始まるインタラクティブなメタファーを利用してください。そして、現実世界で可能なことを超えて、デジタルで起こりえることを囲い込んでください。

<ul>
<li>例えば、フォトアプリケーションでフリックで写真を移動させることができるでしょう（現実の動きを模倣して）。そして、ユーザーは簡単な操作で写真を拡大することもできます。（この場合は仮想空間だけで可能ですが）<br/><img src="http://taninno.github.com/images/surface/033.png" width="240"/></li>
</ul>
</li>
<li>mass(?)や加速、摩擦、粘性、重力を利用して状態推移の現実世界を模倣してください。

<ul>
<li>例えば、SDKにある<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.controls.scatterview.aspx">ScatterView</a>コントロールは簡単にそれらの効果を可能にします。</li>
</ul>
</li>
<li>オブジェクトとコンテンツの慣性を使用してください。</li>
</ul>


<p>これらは各アプリケーションの体験を通して矛盾の無い体験を作るのに貢献します。<a href="http://msdn.microsoft.com/en-us/library/ff727815.aspx">Surface SDK</a>の慣性処理は慣性を実行しやすくします。</p>

<div id="section3-1-4"></div>


<h3>4. 常にタッチに反応すること</h3>

<p>ユーザーは動かない何かを試すことがあり（？）、それを受けて、視覚的なフィードバックがそれらを学習し、問題解決かポジティブな方向へ促すことを助けるべきです。</p>

<h4>a. ユーザーを視覚的なヒントと間に合わせのクロムで誘導させる</h4>

<ul>
<li>ユーザーにインタラクションがすべきことについての視覚的なヒントを提供する。   + 例えば、ランチャーの回転ハンドルは、視覚的なヒントを使用しています。それはコントロールを回転させるためのタッチインタラクションであることです。<br/><img src="http://taninno.github.com/images/surface/034.png" width="140"/></li>
<li><p>インタラクションを誘導するために、間に合わせのクロムを使用します。間に合せのクロムはコントロールが必要なときだけ公開されることを意味します。</p>

<ul>
<li>例えば、フォトアプリケーションで、ElementMenuがスクリーンに常にいるよりは、個々の写真をタッチして現れるべきです。<br/><img src="http://taninno.github.com/images/surface/035.png" width="140"/></li>
</ul>
</li>
</ul>


<h4>b. 即時の喜びと達成感を確保する</h4>

<ul>
<li><strong>視覚的にタッチを認識する</strong>
タッチの視覚化は素早く正確にアプリケーションがタッチを視覚的に認識することを見越しておく。<br/><img src="http://taninno.github.com/images/surface/036.png" width="140"/>

<ul>
<li>すべてのコンテンツはタッチに反応し、即時視覚化しなければならない。</li>
<li>タッチは深さや、白熱光か他の可視化を認識することができる。</li>
</ul>
</li>
<li>アプリケーションは即時にタッチポイントに即時に反応しなければならない。</li>
<li>ユーザーに体験を制御させ、過度のオート操作を提供してはいけない。</li>
</ul>


<h4>c. 魅力のある知覚的フィードバックを提供する</h4>

<p>ビジュアルやサウンド、モーション、フィジカルインタラクションを通して、ユーザーが感知する魅力的なフィードバックを提供する</p>

<ul>
<li>シナリオに適して、楽しませるビジュアルを盛り込む。</li>
<li>ユーザーが何か起こったのかを理解するのを、助けるアプリケーションに適したサウンドを盛り込む。</li>
<li>ビジュアルが合図を送り、ユーザーをアプリケーションの新しい環境やポイント、効果を導くヒントを伝える。

<ul>
<li>例えば、アプリケーションはアニメーションを使って、インタラクションを教え、機能を導くヒントを伝えることができる。</li>
</ul>
</li>
</ul>


<h4>d. 視覚的なヒントとタッチインタラクションを教えるためのガイダンスアニメーションを使用する</h4>

<ul>
<li><p>目に見えないコンテンツに対して視覚的なヒントを提供する。直感的に、非階層アプローチの探索はSurfaceの体験の基本です。そして、時々ユーザーがそれらをガイドする手がかりとヒントを要求します。<br/><img src="http://taninno.github.com/images/surface/037.png" width="140"/></p>

<ul>
<li>例えば、ランチャーアニメーションはアプリケーションのアイコンがスクロール・インするのを表示します。そして、アイコンがランチャーがスクロール可能だということ、追加のコンテンツがあることを示すために縮みます。</li>
</ul>
</li>
<li><p>ユーザーの謝った行為を防ぐために、視覚的なヒントを提供します。</p>

<ul>
<li>例えば、ユーザーが取り出せないディスプレイの範囲外のコンテンツを外側に移動することを許可しません。<br/><img src="http://taninno.github.com/images/surface/038.png" width="140"/></li>
</ul>
</li>
<li><p>機能を明らかにするためにガイダンスアニメーションを使用します。</p>

<ul>
<li>例えば、音楽を探すアプリケーションで、アルバムのジャケットがScatterViewItem
です。ユーザーがそれらをタッチすることができ、フリックするとアルバムのコンテンツが明らかになります。アプリケーションが起動した時、ジャケットは特定の場所にアニメーションし、幾つかのアルバムは追加コンテンツがあることをデモンストレーションのためにひっくり返ります。</li>
</ul>
</li>
</ul>


<div id="section3-1-5"></div>


<h3>5. コンテンツに基づいた体験を作る</h3>

<p>コンテンツ指向のアプリケーションは探索と発見を促します。コンテンツにフォーカスされた体験はユーザーが使う上でより直感的に楽しくあります。</p>

<h4>a. コンテンツをインターフェイスとする</h4>

<ul>
<li>ダイレクトタッチインタラクションを、ボタンやメニューやスライダーのようなUIコントロールに置き換えないでください。</li>
<li>スクリーンを不必要で余分なUIコントロールとクロムで散らかさないでください。</li>
<li>プライマリインタラクションとしてタッチを取って代わらないでください。

<ul>
<li>プライマリインタラクション（タッチ）を置き換えると行った方法で、外部の入力デバイスをSurfaceと接続しないでください。</li>
</ul>
</li>
<li>アプリケーションはそれを置き換えることなく、Surfaceのタッチエクスペリエンスをサポート、推奨しなければなりません。</li>
</ul>


<h4>b. インタラクティブな要素は特定しやすいようにする</h4>

<ul>
<li>視覚的なタッチコンテンツのサインは、ユーザーがインタラクティブでない何かをタッチすることを誤らないように正確であるようにしてください。

<ul>
<li>例えば、非活性ボタンは必ず視覚的な活性ボタンとは異なるようにしてください。<br/><img src="http://taninno.github.com/images/surface/039.png" width="240"/></li>
</ul>
</li>
<li>大きなインターフェイスの要素だと、より速くユーザーがインタラクティブを特定できるようにしてください。<br/><img src="http://taninno.github.com/images/surface/040.png" width="240"/></li>
<li>オブジェクトがインタラクティブかどうかを示すのを助けるような、深度（重なり）を使用してください。<br/><img src="http://taninno.github.com/images/surface/041.png" width="140"/></li>
</ul>


<h4>c. エクスペリエンスに重点を置く</h4>

<ul>
<li>アプリケーションのいくつかの機能を減らしてください。個々のアプリケーションのシナリオをユーザーが使える必要性に対応する（？）。</li>
<li>個々の機能とユーザーに明らかなそれらのタスクに、焦点をあてた機能のセットに重点をおいてください。</li>
<li>ユーザーが決めるのに時間がかかったり複雑さを減らすために、似たような選択肢は制限してください。

<ul>
<li>複製されたコントロールといくつかの機能を提供するインターフェイスは混乱させます。</li>
<li>たくさんの選択肢が必要となった時は、<a href="http://msdn.microsoft.com/en-us/library/ff727728.aspx">ElementMenu</a>を使用してください。<br/><img src="http://taninno.github.com/images/surface/elementmenu.png" width="140"/>

<ul>
<li>シンプルで組織化された階層的な構造</li>
<li>ユーザーはタップとスライドでメニューを通してナビゲートすることができます。</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>d. 行動と学習を統合する</h4>

<ul>
<li>もし使用上の注意が必要であれば、それらとアプリケーションの流れを統合して、コンテンツから注意を外さないようにしてください。</li>
<li>主要機能はすぐに見つかるようにしてください。</li>
</ul>


<div id="section3-1-6"></div>


<h3>6. トランジションの注意</h3>

<h4>a.トランジションは滑らかで流れるようでなければいけません</h4>

<p>滑らかなトランジションはユーザーにそれがあることの文脈（背景）を知らせます。<br/><img src="http://taninno.github.com/images/surface/042.png" width="240"/></p>

<ul>
<li>滑らかな各トランジションはユーザーに連続したフローをし続けます。</li>
<li>不快なトランジションは避ける。

<ul>
<li>滑らかなトランジションは、ユーザーを適用させ続けることを助けます。</li>
</ul>
</li>
<li>突然現れたり、消えたりすることはありません。</li>
<li>各オブジェクトと視覚的な要素の変更は、滑らかに活動させ以降して、無くなるか途中で変わるかします。<br/><img src="http://taninno.github.com/images/surface/043.png" width="240"/></li>
</ul>


<h4>b.意図的ではないものか有害な主要トランジションかを避ける</h4>

<ul>
<li>ユーザーにより、破壊と明確に意図した作動された大きな変更を要求する。

<ul>
<li>例えば、アクセスポイントは、アプリケーションを離脱するか始めるための明確な入力を要求します。この２ステップの方法は想いもしない予期しない起動を引き起こします。<br/><img src="http://taninno.github.com/images/surface/044.png" width="240"/></li>
</ul>
</li>
<li>フレンドリーで歓迎するアプリケーションの環境を作成します。それはユーザーが簡単に探したり、実験するために招待します。</li>
</ul>


<div id="section3-2"></div>


<h2>セクション 3.2: ビジュアル＆モーションデザインガイドライン</h2>

<p>このセクションでは、ビジュアルデザインとモーションデザインに関する個々のデザインガイドラインを提供します。</p>

<div id="section3-2-1"></div>


<h3>1. 方向とレイアウト</h3>

<p>Surfaceでのビジュアル要素のレイアウトは、興味深い機会に360度のマルチユーザーインターフェイスを提供します。ほとんどのアプリケーションでは、ほとんどの人はディスプレイのどの側からでも、読んだり、理解したり、スクリーンのオブジェクトと相互にやり取りしたりできるべきです、いつでも。Surfaceにしばし「絶対的な方向」はありません。それどころか明確な上、下、左または右はありません。各ユーザーの相対的な位置の観点で考えることがベストです。どこにオプジェクがいても回転されたり、配置されたり、デバイスを使っているユーザーから離れたりするかもしれません</p>

<h4>a. アプリケーションの方向</h4>

<p>アプリケーションが起動された時、デフォルトの方向が最もデバイスの周囲にいるユーザーにとってメリットがあることを確実にします。</p>

<p><em>水平での展開</em></p>

<ul>
<li>もしアプリケーションが自由な方向のコンテンツを持つことができたら、コンテンツが回転でき、動かせることをユーザーに示すべきです。</li>
<li>もしアプリケーションが特定の方向に向かなければならないのであれば、ランチャーと同じ方向に従うべきです。</li>
</ul>


<p><em>垂直での展開</em></p>

<ul>
<li>アプリケーションはスクリーンの下に向かってのみ正しい方向に置くことができます。そして、アプリケーションは（水平と同じように）ランチャーと同じ方向に従うべきです。</li>
</ul>


<h3>b.フリーグリッドレイアウト</h3>

<p>多くのビジュアルデザイナーはグリッドをベースにしたレイアウト作成を学んできました。360度のSurfaceの性質は、グローバル（？）、ワイドスクリーン、グリッドシステムを用いないレイアウトにとって良いものです。これにはビジュアルレイアウトの新しい考え方を必要とします。Surface SDKの<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.controls.scatterview.aspx">ScatterView</a>コントロールは、すぐに簡単な方法でグリッドフリーグローバルレイアウトを作成できます。それはユーザーに準備させ、コンテンツを探索することを勇気づけます。ScatterViewは目に見えないオブジェクトのコンテナーを演じます。いくつかのコンテンツは、デフォルトでスクリーンの端に向かって正しい方向に向くことになります。好奇心として、ダイレクトタッチインタラクションとして、探索としても演じます。<br/><img src="http://taninno.github.com/images/surface/045.png" width="240"/></p>

<p>ただ、レイアウトは常にグリッドフリーを必要としません。例えば、<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.controls.librarycontainer.aspx">LibraryContainer</a>コントロールは、すぐにグリッドフリーレイアウトのセクションの順番で作成します。そして、コンテンツは簡単にソートされ、フィルター、体系化されるでしょう。アプリケーションはユーザーに決めさせることができます。異なる視覚的な組織化の方法を、いつ切り替えるかどうかを。（LibraryContainerは以下の図のようにコンテンツを束にしたり、一覧のように並べかえることができます。）<br/><img src="http://taninno.github.com/images/surface/046.png" width="240"/></p>

<h3>c.格子レイアウト</h3>

<p>グリッドをベースにしたレイアウトは、まだ立場を持っており、現在のSurfaceアプリケーションに役立つことができます。格子状のレイアウトは、生産性やアクティビティ、データのソーティングに適しており、簡単に視覚的なリズムを生み出すことができます。Surfaceの体験に向けたレイアウトグリッドはローカル（特有な個々のコンテンツアイテム）にも、グローバル（ワイドスクリーン）にも可能です。</p>

<ul>
<li><p><strong>ローカルグリッド</strong>
特別なオブジェクトに適用するレイアウトシステムがあります。画面の全体にではなくです。特に役立つローカルグリッドの実装は<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.controls.scatterviewitem.aspx">ScatterViewItem</a>の内部で行われます。ScatterViewを用いて360度のアプリケーションを作ることが可能になります。しかし、ローカルグリッドは体系化と構造を与えるScatterViewの内部で利用できます。<br/><img src="http://taninno.github.com/images/surface/047.png" width="240"/></p></li>
<li><p><strong>グローバルグリッド</strong>
グローバルグリッドはコンテンツとアプリケーション全体のコントロールの範囲を決定します。ワイドスクリーンのグローバルグリッドは、複製されたコントロールが各ユーザーに用意された時、又はスクリーンの両側に配置された時に役立ちます。簡単に調査し、体系化することを可能にしている間に、しばし、スクリーンの一方方向に向かってUI全体を押し進めます。それが、ユーザーの共同を難しくさせます。もしグローバルグリッドで要素をレイアウトしているとしたら、各ユーザー、各側へのコンテンツの方向の考察を気にかけてください。<br/><img src="http://taninno.github.com/images/surface/048.png" width="240"/></p></li>
</ul>


<div id="section3-2-2"></div>


<h3>2. 深度</h3>

<p>Z軸か深度を使用して、コンテンツの編成と視覚的な優先順位付けがよりパワフルになります。深度は要素の表面を背景から分離することを助けます。そして、操作可能なものとそうでないものを明確に分離することも助けます。Surfaceアプリケーションは深度をあらゆる場所の体験と様々な状態のアトラクト（水の波紋がある画面のことです）、ランチャーそしてアプリケーションのトランジションに使用します。<br/><img src="http://taninno.github.com/images/surface/049.png" width="240"/></p>

<ul>
<li>深度を優先度、順番、コンテンツアイテム間の集中を表すために使用します。</li>
<li>浅く、かすかで、上品な深度の見え方を維持してください。</li>
<li>オブジェクトとコンテンツにうまくタッチできると認識するために深度を使用してください。タッチに成功した指に向かって浮いてるコンテンツのような錯覚を与えてください。それらのタッチされたアクティブなオブジェクトは最も高い深度を確保してください。</li>
<li>コンテンツとタッチ可能な領域を視覚的に示したコントロール内部で深度を使用してください。</li>
</ul>


<h3>a. 2.5次元の深度の作成</h3>

<p>2.5次元はシミュレーターや、本当の3次元ジオメトリックスを使わない深度で錯覚させる技術に代表されます。いくつかの技術は特別なXAMLを用いた3次元ツールとハイパフォーマンスなWPFを無しで実現されます。</p>

<h4>i. 拡縮</h4>

<p>拡縮は深度をシミュレーションすることができます、特に他の技術と結合して。拡縮はタッチ入力の成功を登録させるために望ましい方法です。それは、少し拡大を増加させ（または錯覚のために）、オブジェクトが指に帯磁する印象を与えます。異なるレベルの深度で拡縮が大きな違うと、深い背景の見かけに繋がることがあります。ユーザーに没頭した体験を維持するため、小さな微かな拡大の変化を使います。<br/><img src="http://taninno.github.com/images/surface/050.png" width="240"/></p>

<h4>ii. ドロップシャドー</h4>

<p>かすかなドロップシャドーは簡単に深度を示すのに効果的な方法です。しかし、重すぎにすることは重要ではありません。ダークシャドーはコンテンツの下を目立たなくさせることができます。そして、とても大きな補正値は、ディスプレイからオブジェクトが繋がってないのではと感じさせることができます。<br/><img src="http://taninno.github.com/images/surface/051.png" width="240"/></p>

<h4>iii. 透過</h4>

<p>透過は、上のオブジェクトを通して低いレベルのオブジェクトを表示するに深度を利用することができます。この技術は少ない数のオブジェクトに対しては有効です。その一方で、透過にはレンダリングするための計算が高くなることがあります。<br/><img src="http://taninno.github.com/images/surface/052.png" width="240"/></p>

<h4>iv. 遠近感を与える</h4>

<p>奥行きの付与は、着色、彩度の縮小、両方またはいずれか一方の離れたオブジェクトをシミュレーションするためにコントラストの低下を使用します。深度を伝達するための明るさのかすかな低下は、すぐに効果を出すことができます。<br/><img src="http://taninno.github.com/images/surface/053.png" width="140"/></p>

<h3>b. 3次元の深度の作成</h3>

<p>本当の3Dは現実の3次元ジオメトリックのレンダリングを使用します。このため、現実的なキューブの回転やシェイプ、カスタム3Dモデリングなどなどを有効（可能）にします。3DはXAMLやWPFを利用して生み出すことができるとはいえ、それは逆にアプリケーションのパフォーマンスに影響を与えることになります。本当の3DはXNAを使用したSurfaceで作成、配信されるのがベストです。それはMicrosoftの3Dのコアでゲームエンジンです。<br/><img src="http://taninno.github.com/images/surface/054.png" width="180"/></p>

<p>真の3Dはインターフェイスの革新の多くの機会を与えます。しかし、3Dコンテンツをデザインする時には注意が必要です。2次元のタッチSurfaceで3Dのオブジェクトをコントロールすることは難しく混乱させることがあります。3Dは以下を常に避けるべきです。幾つかのテキストやラベルが3Dの表面上に配置され、読むことが難しくなるコンテンツの作成を。<br/><img src="http://taninno.github.com/images/surface/055.png" width="340"/></p>

<p>3Dの深度を使用してスクリーン上のオブジェクトを説明はできないと考えます。しかし、それよりむしろバーチャル空間はでアプリケーションの中でユーザーを導きます。</p>

<h3>c. 視覚的な手がかりとしての深度</h3>

<p>深度はタッチ入力が操作可能な領域を示すことにも使用することができます。これはユーザーが、他のタッチしたことよりも異なる結果になることを理解することを助けます。例えば、ヘッダーかコンテンツのタイトルバーはドラッグできるように見えます。しかしオブジェクトの中のリストアイテムはドラッグした時にスクロールします。コントロールの一部分を、それらの領域をユーザーが特定することを助けることができる他の要素の上か下かに表示します。それらの目的を簡単に理解させます。（？）<br/><img src="http://taninno.github.com/images/surface/056.png" width="340"/></p>

<div id="section3-2-3"></div>


<h3>3. 形状</h3>

<p>Surfaceのコンテンツの形状は機能を視覚的に示さなければなりません。</p>

<h4>a. 境界と端</h4>

<p>アプリケーションのエッジとコーナーのスタイルは、ユーザーの趣味に合うのエクスペリエンスの感情を与えます。</p>

<ul>
<li>Style 1: <strong>平面</strong></li>
</ul>


<p>Surfaceのアクセスポイントとランチャーは簡潔、フラット、シンプルでデジタルであることが重要です。この様式はアクセスポイントとランチャーが、Surfaceの体験をナビできる操作可能な要素として示します。それらのナビゲーションコントロールはコンテンツの次（補助的な）です。それらナビは注意をそららさず、ユーザーが次の体験を得ることを助けます。<br/><img src="http://taninno.github.com/images/surface/057.png" width="380"/></p>

<ul>
<li>Style 2: <strong>自然</strong></li>
</ul>


<p>アトラクト状態は容積、自然な形状に基づいています。それらは試しのタッチを勧めます。丸みを帯びた自然な形状は一般的に親しみやすさや見つけやすさ、没入感に優れています。<br/><img src="http://taninno.github.com/images/surface/058.png" width="380"/></p>

<p>それら（平面と自然）の様式のバランスはアプリケーションに適した体験を得ることを助けます。</p>

<h4>b. 罫線と輪郭</h4>

<p>Surfaceのインターフェイスは、一般的に自由なアウトラインで、コンテンツのフォーカスを維持します。もしインターフェイス要素がアウトラインを要求したら、最小2pxの罫線を維持してください。回転や拡縮した時にベストな結果を生み出します。<br/><img src="http://taninno.github.com/images/surface/059.png" width="180"/></p>

<div id="section3-2-4"></div>


<h3>4. テクスチャー</h3>

<p>一般的に、奇麗に装飾されたテクスチャーの使用はSurfaceの体験では推奨されません。装飾的なテクスチャーはコンテンツを損なう傾向があります。コンテンツは常にエクスペリエンスのコアであるべきです。概して単に美学の理由で利用されるテクスチャーが作る体験は本当のデジタルではありません。</p>

<p>テクスチャー自体がコンテンツであるアプリケーションもいくつかはあるかもしれません。もしテクスチャーがアプリケーションで使用しなくてはいけないとしたら、ミニマムで一貫性を維持し、常にタッチと探索を推奨することにフォーカスさせます。</p>

<p>テスクチャーが視覚的なヒントとしてユーザーへアプリケーションの使用を助けるために演じている間は、他の多くのビジュアルデザインテクニックが同じゴールを達成ことができます。それは、ナビゲーションスペース、シェイプ、フォーム、形状、配色などなど。視覚的なヒントとしてのテクスチャーの使用に変わるものを探索してください。</p>

<div id="section3-2-5"></div>


<h3>5. 配色</h3>

<p>デザイナーは実証された配色デザインのガイドラインに従わなくてはいけません。そして、彼らがハンドリングしている特定のブランドの要求を考慮しなくてはいけません。それにはいくつかの追加のガイドラインがあります。Surfaceのディスプレイに色彩再現を最適化させることです。</p>

<h4>a. 配色の利用</h4>

<ul>
<li><p>デザインプロセスの中で全ての配色を試験します。反復の試験は一貫性や明るさやSurfaceのスクリーンで最適化された配色を獲得するベストな方法です。試験のためにデスクトップモニターに頼らないでください。</p></li>
<li><p>背景色に真っ白な色は使わないでください。</p></li>
<li><p>まぶしさや飽和したトーン（色調）は狭い範囲で目の疲労を減少させることの最良の方法です。</p></li>
<li><p>ハイコントラストや真っ黒や真っ白はアンチエイリアス（表面要素の端が背景の上でかすかに混ざり合う）の有効性を減少します。文字が見えづらいようにさせ、回転したときにオブジェクトとコンテンツの端にギザギザの段々の効果を発行させます。</p></li>
<li><p>全てのアクションに対してステージを背景のように扱います。それは繊細で快適でありながら地味であるべきです。</p></li>
<li><p>慎重に、繊細な傾斜をつけます。コントラストを減らした配色は繊細な傾斜は１つの統一されたトーンとして平坦にし、表示されるようになるはずです。</p></li>
<li><p>バンディング（プリンタで印刷するときにトナーが少ないなどの理由で濃淡の縞が発生すること）の確認のためにもSurfaceのディスプレイで色調の傾斜をテストしてください。</p></li>
<li><p>実験や反復そして探索はSurfaceのディスプレイの特性を良く理解することになります。先入観を持たずに、確立された配色パターンに対して、新たなアプローチをとってください。</p></li>
</ul>


<h4>b. Surfaceカラー</h4>

<p>管理者はSurfaceのカラースキームのデフォルトを制御します。国際的なカラースキームはアプリケーションでレンダリングされるSurfaceコントロールのデフォルトカラーを決定します。アプリケーションの追加要素のスタイルにも同じ配色を使用することができます。また一方で、それらを使ったアプリケーションのいくつかの要素に影響を及ぼすSurfaceカラーを上書きすることができます。</p>

<p>Surfaceには既に定義された4つの配色パターンがあり、<a href="http://msdn.microsoft.com/en-us/library/microsoft.surface.presentation.palettes.aspx">Microsoft.Surface.Presentation.Palettes</a>名前空間で定義されています。</p>

<ul>
<li>Light palette</li>
<li>Dark palette</li>
<li>LightHighContrast palette</li>
<li>DarkHighContrast palette</li>
</ul>


<div id="section3-2-6"></div>


<h3>6. タイポグラフィー</h3>

<p>Surfaceアプリケーションのタイポグラフィーは意味のある優雅でなくてはいけません。Surfaceの体験の中心にあるシンプルなインターフェイス要素とコンテンツを伴って、スクリーン上のテキストそれ自体がインターフェイスとしてさらに振る舞う機会を持ちます。</p>

<h4>a. Segoe360</h4>

<p>Segoe360はSurface用に特別に設計された書体です。Segoe360をアプリケーション内で使用を強く推奨される理由は以下の通りです。</p>

<ul>
<li><p>Segoe360は3つの大きさ（レギュラー、イタリック、ボールド）があります。<br/><img src="http://taninno.github.com/images/surface/060.png" width="180"/></p></li>
<li><p>Segoe360のレギュラーは、Segoe UIとSegoe UI Semiboldの間の新しい大きさであり、Surfaceでより存在感を持つように設計されています。<br/><img src="http://taninno.github.com/images/surface/061.png" width="180"/></p></li>
<li><p>文字はどのアングルから見ても区別しやすいように変更され、どの方向からも読みやすくなりました。例えば、小文字のl（エル）は大文字のI（アイ）よりもより区別しやすくなり、小文字のq（キュー）は小文字のb（ビー）が回転した時よりも区別しやすくなっています。<br/><img src="http://taninno.github.com/images/surface/062.png" width="180"/></p></li>
<li><p>トラッキング（全体の文字間隔）はより読みやすくするために増加し、スクリーンに最適化されました。特に小さな文字に対して。</p></li>
<li><p>カウンター（aやeのような文字の閉じているエリア）は小さいサイズでも可視性が保たれるように広くしました。</p></li>
<li><p>Segoe360は西ヨーロッパや東ヨーロッパ、トルコ、バルト、ギリシャ、キリルの文字セットをサポートしています。</p></li>
</ul>


<p>Segoe360の最小サイズ</p>

<ul>
<li>インターフェイス要素のラベルには12pt</li>
<li>本文や文章には16pt<br/><img src="http://taninno.github.com/images/surface/063.png" width="280"/></li>
</ul>


<h4>b. 書体の選択</h4>

<p>SurfaceアプリケーションではSegoe360が推奨されますが、常に個々のブランドやシナリオにフィットするわけではないかもしれません。</p>

<p>代替の書体を選択する際には、回転や視認性、適用性を考慮する必要があります。サンセリフ体（文字の端にある飾りがない書体のことです）は概してセリフ体（逆に飾りがある書体のこと）よりも推奨されます。わずかな飾りや横幅の一貫性、そして気前のよいナビゲーションスペース（？）が理由です。Surfaceに代替の書体を選定して使用する時は充分に注意してください。最終的な選考の前にSurfaceのディスプレイで可読性を必ずテストしてください。<br/><img src="http://taninno.github.com/images/surface/064.png" width="320"/></p>

<ul>
<li><p>アプリケーションの開発中、その前から、全てのアングルでテキストのレンダリングを評価してください。</p></li>
<li><p>全てのを大文字か小文字で使用するのは避けてください。文章の場合、大文字はより自然に、読みやすく、めったに挑戦的なトーンを伝えません。</p></li>
<li><p>セリフ体が視覚のブランドエクスペリエンスの無くてはならない一部であれば、可読性を高めるために30ptかそれ以上に設定してください。</p></li>
<li><p>ハイコントラストな植字は可読性を損ないます。黒背景に白い文章は縁がざらつき、かわいそうなリーディングエクスペリエンスとなります。</p></li>
<li><p>曲線状のパスに沿って文章を配置することは避けてください。</p></li>
<li><p>ほとんどのSurfaceのオブジェクトとコントロールは自由なスケールを持つことを忘れないでください。最小スケール限界を実行したオブジェクトは最大テキストの可読性を維持する必要が時々あります。</p></li>
<li><p>フォントレンダリングのテストをSurface自身で行うことの代わりはありません。読みやすさのテストは行わなければなりません。文章が回転や拡縮しているときもです。</p></li>
</ul>


<p>フォントサイズの最小の選択肢</p>

<ul>
<li><p>インターフェイス要素のラベルには12pt</p></li>
<li><p>本文や文章には16pt</p></li>
<li><p>軽い書体（薄いか狭い幅）には30pt</p></li>
<li><p>セリフ体（文字の線の終わりにある&#8221;拡張&#8221;を含むもの &ndash; ひげのこと）には30pt</p></li>
</ul>


<div id="section3-2-7"></div>


<h3>7. イコノグラフィー</h3>

<p>アイコンはエクスペリエンスを支えることができますが、使用する意図が必要です。</p>

<h4>a. 視覚的な手がかりとしてのアイコン</h4>

<p>アイコンは視覚的に機能を伝えることに役立ちます。ボタンや他のコントロールの機能は常にユーザーにとって明らかでは限りませんし、小さなコントロールの上でテキストラベルを使うことが常に適してるとは限りません。そのような場合には、シンプルでありながらアイコンはテキストボタンラベルの補足として使用することができます。40個以上のサンプルセットがSurface 2.0 SDKで配布されています。<br/><img src="http://taninno.github.com/images/surface/065.png" width="320"/></p>

<p>適切なダイレクトタッチインタラクションが可能である場合には、機能の手がかりとしてアイコンを使用したり、アイコンボタンを使用しないでください。例えば、ランチャーの隅に置かれた回転ボタンを配置するより、すでにランチャーは回転しやすくあります。ランチャーはユーザーに操作を促すために繊細な回転矢印を使用しています。</p>

<h4>b. カスタムアイコンの作成</h4>

<p>もしアプリケーションでサンプルアイコンに含まれていないアイコンが必要であれば、次のカスタムアイコン開発のガイドラインに従ってください。</p>

<ul>
<li><p>アイコンはシンプルな矩形でなくてはいけません。</p></li>
<li><p>アイコンは限らせた細かさでなくてはいけません。</p></li>
<li><p>アイコンは拡縮可能でなくてはいけません。</p></li>
<li><p>アイコンは現実世界のメタファーを利用しなければいけません。</p></li>
<li><p>アイコンは同じよう重量感でなくてはいけません。</p></li>
</ul>


<div id="section3-2-8"></div>


<h3>8. モーションデザイン</h3>

<p>モーションデザインはどのようにものがスクリーン上を動くのかを定義した、Surfaceのエクスペリエンスの重要な１つです。アニメーションは常にコンテンツと全体の体験をサポートします。モーションデザインは「アニメーション」と「感情、エネルギー、コネクションそして反応性を伝える効果」を提供します。それらは視覚的なヒント、行動を促すきっかけ、コンテンツの探索を招待することを提供します。</p>

<h4>a. トランジション</h4>

<p>トランジションは文脈を与え、ユーザーがどこにいるのかの視覚的なヒントを提供します。それらはユーザーが<a href="http://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%B3%E3%82%BF%E3%83%AB%E3%83%9E%E3%83%83%E3%83%97">メンタルマップ</a>を作成する助けになります。どのようにコントロールを使うのか、長く表示されていない時でも、スクリーン上のどこにオブジェクトがあるのかを忘れないために、トランジションは助けになります。<br/><img src="http://taninno.github.com/images/surface/066.png" width="480"/></p>

<p>トランジションはナビゲーションコンテキストを提供する深度を利用した幾つかのモード（アトラクト・ランチャー・アプリケーション）の間を移動するモデルとなります。例えば、ランチャーに入るためにアトラクトを離れたときに、アトラクトはZスペースを押しのけます（ランチャーの後ろに移動します）。ランチャーからアプリケーションを起動したときに、ランチャーはZスペースを戻り、アトラクトはもっと遠くに戻ります。これはユーザーに体験を通して移動する方法に関する重要な文脈を提供します。</p>

<p>トランジションの言語や機能や文字、スタイルが適したモデルを開発します。開発中のアプリケーションの種類を検討し、フィットして適したトランジションを作成してください。</p>

<p>ゲームで発生するトランジションは楽しく面白くあるでしょうし、健康管理アプリケーションでのトランジションは手短に簡潔であるべきでしょう。</p>

<p>トランジションがしなければならないこと：</p>

<ul>
<li>シームレスであること</li>
<li>意味を持つ</li>
<li>参考になる</li>
<li>適切である</li>
<li>時間に注意してください。コンテンツにアクセスするためだけに長いトランジションを強要させユーザーにフラストレーションを与えないでください。</li>
<li>前後関係のあるナビゲーションを用意してください。</li>
<li>アプリケーションの物語を強化してください。</li>
</ul>


<h4>b. 視覚的なヒントのためのトランジション</h4>

<p>モーションデザインはユーザーが観察を通して即座に学べるツールを提供します。チュートリアルや長ったらしいデモンストレーションを無しで。</p>

<p><img src="http://taninno.github.com/images/surface/067.png" width="280"/><br/>例えば、ランチャーが後ろのフェードインしてくるコンテナーをロードしている時に、アプリケーションアイコンはスライドし、背景のコンテナーの端に到達したらアプリケーションのアイコンは縮みます。ユーザーはこの動き見て、見えてるものよりもオプションがあることを理解します。スライドの動きはコンテンツがスクロール可能だということのヒントになります。</p>

<p>もし、ランチャーのコンテナーがスクリーン上にトランジションもなく突然現れたりしたら、難しくもないのに動かないように見えてしまいます。ユーザーにコンテンツが移動可能で、現在表示されているものよりも多くのオプションが使用可能だということを知らせることは難しいでしょう。そのため、視覚的に機能を示唆する方法のためにトランジションを使用することには、ともて価値があります。</p>

<h4>c. アニメーションのガイドライン</h4>

<p>アニメーションガイドラインはユーザーにどのようにしてタスクを達成するための特有のタッチ操作を行うのかを教えます。それらは、特定のボタンアイコンやコンテンツの一部で使われ、ユーザーへ視覚的にタスクを説明するためフィードバックを提供する方法を伝えます。<br/><img src="http://taninno.github.com/images/surface/068.png" width="380"/></p>

<p>例えば、アクセスポイントはユーザーに特定のタッチ操作を教えるためにアニメーションガイドラインを使用します。誰かがアクセスポイントをタッチしたとき、視覚的なインジケーターやアクションワードがアクセスポイントから外に動きます。もしユーザーがアクセスポイントをスライドするか、アクションワードをタップしたら、それらがSurfaceの次の体験へと誘導します。</p>

<h4>d. 周囲のアニメーション</h4>

<p>アンビエントアニメーションは、システムが生きて、起動、待機していることを示すために使用される繊細なアニメーションです。それらは、ブランドとアプリケーションの魅力を強化することができます。アンビエントアニメーションはあえて控えめで上品で、繊細で自然なエフェクトを使用します。<br/><img src="http://taninno.github.com/images/surface/069.png" width="380"/></p>

<p>背景の繊細なアンビエントアニメーションはSurfaceのエクスペリエンスに明るい本質を与えます。ユーザーにアプリケーションがレスポンスティブで動いていることを確実にするためにアンビエントアニメーションを使用してください。</p>

<div id="section3-3"></div>


<h2>セクション 3.3: サウンドデザインガイドライン</h2>

<p>Surface向けのサウンドデザインはSurfaceのデザイン原則から大きく引き出さなければいけません。アプリケーションでサウンドを使用するか作る場合に、次のガイドラインを忠実に守ってください。</p>

<ul>
<li><p>シンプルで繊細なサウンドにしてください。</p></li>
<li><p>サウンドが本当のデジタルであることを保証してください。</p></li>
<li><p>思慮深いサウンドを使用してください。サウンドはしばしば公共な場で聞こえづらいことがあります。もしサウンドが高圧的であったり、ユーザーの気に障るようであれば、ユーザーがスピーカーをミュートにするかアプリケーションを削除できるようにしてください。</p></li>
<li><p>サウンドはSurfaceShellやランチャーでのサウンドでも一貫性のあるボリュームにしてください。もしサウンドがアプリケーションのまっただ中で突然上がったら、ユーザーがスピーカーをミュートにするかアプリケーションを削除できるようにしてください。</p></li>
</ul>


<div id="section3-4"></div>


<h2>セクション 3.4: 言語と文章のデザインガイドライン</h2>

<p>Surfaceの体験は基本的にわずかなインターフェイステキストを要求しますが、これは開発しているアプリケーションにより変化するでしょう。文章はコンテンツ指向であり、思慮深く使用されるべきです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[first post]]></title>
    <link href="http://taninno.github.io/blog/2012/08/02/post-title/"/>
    <updated>2012-08-02T00:36:00+09:00</updated>
    <id>http://taninno.github.io/blog/2012/08/02/post-title</id>
    <content type="html"><![CDATA[<p>test post</p>
]]></content>
  </entry>
  
</feed>
